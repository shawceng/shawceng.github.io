<!--
	作者：Sariay
	时间：2018-08-26
	描述：There may be a bug, but don't worry, Qiling(器灵) says that it can work normally! aha!
-->
<!DOCTYPE html>
<html class="html-loading">
		

<head>
	<meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <title>
    
      Dubbo | Shawceng的技术手札
    
  </title>
  <meta name="author" content="Shawceng">
  <meta name="keywords" content="" />
  <meta name="description" content="" />
	<!-- favicon -->
  <link rel="shortcut icon" href="/img/favicon.ico">

  <!-- css -->
  
<link rel="stylesheet" href="/css/Annie.css">

  
  <!-- jquery -->
	
<script src="/plugin/jquery/jquery.min.js"></script>


<script>
    const CONFIG_BGIMAGE = {
      mode: 'random',
      normalSrc: '/img/header-bg.jpg',
      randomYouMax: 110,
      randomYouSrc: 'https://sariay.github.io/Random-img/',
	  randomOtherSrc: 'https://api.berryapi.net/?service=App.Bing.Images&day=-0',
	  preloaderEnable: true
    }
	
    const CONFIG_LEACLOUD_COUNT = {
      enable: false,
	  appId: 'AU8...',
	  appKey: '4cU...',
	  serverURLs: 'http' || ' '
    }
  </script>
<meta name="generator" content="Hexo 5.3.0"></head>
	<body>
		<!-- Preloader -->

	<div id="preloader">
		<div class="pre-container">
			
				<div class="spinner">
					<div class="double-bounce1"></div>
					<div class="double-bounce2"></div>
				</div>
						
		</div>
	</div>


<!-- header -->
<header class="fixbackground bg-pan-br">
	<div class="mask">
		<!-- motto -->
		<div class="h-body">	
			
				<div class="motto text-shadow-pop-left">
					<p class="content" id="motto-content">获取中...</p>
					<p>-<p>
					<p class="author" id="motto-author">Just a minute...</p>
				</div>
			
		</div>
		
		<!-- others: such as time... -->			
		<div class="h-footer">
			<a href="javascript:;" id="read-more" class="scroll-down">
				<span class="icon-anchor1 animation-scroll-down"></span>
			</a>
		</div>
	</div>
</header>

<div id="navigation-hide">
	<!-- Progress bar -->
	<div id="progress-bar"></div>

	<!-- Progress percent -->
	<div id="progress-percentage"><span>0.0%</span></div>

	<div class="toc-switch"><span class="switch-button">目录</span></div>

	<!-- Page title -->
	<p>
		
			「Dubbo」
		
	</p>

	
	

	<!-- Nav trigger for navigation-H-->
	<a class="nav-trigger"><span></span></a>
</div>

<!-- Navigation in div(id="navigation-H") -->
<nav class="nav-container" id="cd-nav">
	<div class="nav-header">
		<span class="logo"> 
			<img src="/img/logo.png">
		</span>
		<a href="javascript:;" class="nav-close"></a>
	</div>
	
	<div class="nav-body">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	

	
</ul>
	</div>
	
	<div class="nav-footer">
		<ul id="global-social">
	
		<li>
			<a href="http://github.com/shawceng" target="_blank">
				<span class="icon-github"></span>
			</a>
		</li>
			
</ul>

	</div>
</nav>
			
		<!--main-->
		<main>
			<!--
	时间：2018-11-17
	描述：
		插件名称：katelog.min.js
		插件作者：KELEN
		插件来源: https://github.com/KELEN/katelog
-->

	
		<div class="layout-toc">
			<div id="layout-toc">
				<div class="k-catelog-list" id="catelog-list" data-title="文章目录"></div>
			</div>
		</div>

		
<script src="/plugin/toc/katelog.min.js"></script>


		
	 

<div class="layout-post">
	<div id="layout-post">
		<div class="article-title">
			
	<a href="/2021/05/12/notes/framework/Dubbo/" itemprop="url">
		Dubbo
	</a>

		</div>

		<div class="article-meta">
			<span>
				<i class="icon-calendar1"></i>
				
				




	更新于

	<a href="/2021/05/12/notes/framework/Dubbo/" itemprop="url">
		<time datetime="2021-05-12T03:58:17.000Z" itemprop="dateUpdated">
	  		2021-05-12
	  </time>
	</a> 



			</span>
			<span>
						
			</span>
			
			



		</div>

		<div class="article-content" id="article-content">
			<h2 id="1、Dubbo的架构原理"><a href="#1、Dubbo的架构原理" class="headerlink" title="1、Dubbo的架构原理"></a>1、Dubbo的架构原理</h2><h3 id="Dubbo架构图"><a href="#Dubbo架构图" class="headerlink" title="Dubbo架构图"></a>Dubbo架构图</h3><p><img src="/images/dubbo-1.png"></p>
<h3 id="节点角色说明"><a href="#节点角色说明" class="headerlink" title="节点角色说明"></a>节点角色说明</h3><table>
<thead>
<tr>
<th>节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody><tr>
<td>Provider</td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td>Consumer</td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td>Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td>Monitor</td>
<td>统计服务的调用次数和调用时间的监控中心</td>
</tr>
<tr>
<td>Container</td>
<td>服务运行容器</td>
</tr>
</tbody></table>
<h3 id="调用关系说明"><a href="#调用关系说明" class="headerlink" title="调用关系说明"></a>调用关系说明</h3><ol>
<li> provider启动时，会把所有接口注册到注册中心，并且订阅动态配置configurators</li>
<li> consumer启动时，向注册中心订阅自己所需的providers，configurators，routers</li>
<li> 订阅内容变更时，registry将基于长连接推送变更数据给consumer，包括providers，configurators，routers</li>
<li> consumer启动时，从provider地址列表中，基于软负载均衡算法，选一台provider进行调用，如果调用失败，再选另一台调用，建立长连接，然后进行数据通信（consumer-&gt;provider）</li>
<li> consumer、provider启动后，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到monitor<h3 id="整体架构分层设计"><a href="#整体架构分层设计" class="headerlink" title="整体架构分层设计"></a>整体架构分层设计</h3><img src="/images/dubbo-15.png"><br>Dubbo框架设计一共划分了10个层，而最上面的Service层是留给实际想要使用Dubbo开发分布式服务的开发者实现业务逻辑的接口层。图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口， 位于中轴线上的为双方都用到的接口。</li>
</ol>
<ul>
<li>接口服务层(Service):该层与业务逻辑相关，根据 provider 和 consumer 的业 务设计对应的接口和实现</li>
<li>配置层(Config):对外配置接口，以 ServiceConfig 和 ReferenceConfig 为中心 </li>
<li>服务代理层(Proxy):服务接口透明代理，生成服务的客户端 Stub 和 服务端的Skeleton，以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li>
<li>服务注册层(Registry):封装服务地址的注册和发现，以服务 URL 为中心，扩展接 口为 RegistryFactory、Registry、RegistryService</li>
<li>路由层(Cluster):封装多个提供者的路由和负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster、Directory、Router 和 LoadBlancce</li>
<li>监控层(Monitor):RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接 口为 MonitorFactory、Monitor 和 MonitorService</li>
<li>远程调用层(Protocal):封装 RPC 调用，以 Invocation 和 Result 为中心，扩展 接口为 Protocal、Invoker 和 Exporter</li>
<li>信息交换层(Exchange):封装请求响应模式，同步转异步。以 Request 和 Response 为中心，扩展接口为 Exchanger、ExchangeChannel、ExchangeClient 和 ExchangeServer</li>
<li>网络传输层(Transport):抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel、Transporter、Client、Server 和 Codec</li>
<li>数据序列化层(Serialize):可复用的一些工具，扩展接口为 Serialization、 ObjectInput、ObjectOutput 和 ThreadPool<br>根据官方提供的，对于上述各层之间关系的描述，如下所示：</li>
</ul>
<ol>
<li>在RPC中，Protocol是核心层，也就是只要有Protocol + Invoker + Exporter就可以完成非透明的RPC调用，然后在Invoker的主过程上Filter拦截点。</li>
<li>图中的Consumer和Provider是抽象概念，只是想让看图者更直观的了解哪些分类属于客户端与服务器端，不用Client和Server的原因是Dubbo在很多场景下都使用Provider、Consumer、Registry<br>、Monitor划分逻辑拓普节点，保持概念统一。</li>
<li>而Cluster是外围概念，所以Cluster的目的是将多个Invoker伪装成一个Invoker，这样其它人只要关注Protocol层Invoker即可，加上Cluster或者去掉Cluster<br>对其它层都不会造成影响，因为只有一个提供者时，是不需要Cluster的。</li>
<li>Proxy层封装了所有接口的透明化代理，而在其它层都以Invoker为中心，只有到了暴露给用户使用时，才用Proxy将Invoker转成接口，或将接口实现转成Invoker，也就是去掉Proxy层RPC是可以Run<br>的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。</li>
<li>而Remoting实现是Dubbo协议的实现，如果你选择RMI协议，整个Remoting都不会用上，Remoting内部再划为Transport传输层和Exchange信息交换层，Transport层只负责单向消息传输，是对Mina<br>、Netty、Grizzly的抽象，它也可以扩展UDP传输，而Exchange层是在传输层之上封装了Request-Response语义。</li>
<li>Registry和Monitor实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。<h3 id="Dubbo和Spring-Cloud区别"><a href="#Dubbo和Spring-Cloud区别" class="headerlink" title="Dubbo和Spring Cloud区别"></a>Dubbo和Spring Cloud区别</h3></li>
<li>最大的区别就是通信方式不同，Dubbo底层是使用Netty这样的NIO框架，是基于TCP协议传输，配合hession序列化进行RPC调用</li>
<li>SpringCloud是基于Http协议+Rest接口调用远程过程的通信，相比之下，Http拥有更大的报文，rest比rpc更加灵活，不存在代码级别的强依赖<h2 id="2、Dubbo自己的SPI实现"><a href="#2、Dubbo自己的SPI实现" class="headerlink" title="2、Dubbo自己的SPI实现"></a>2、Dubbo自己的SPI实现</h2>Dubbo内核包括四个：SPI（模仿JDK的SPI）、AOP（模仿Spring）、IOC（模仿Spring）、compiler（动态编译）<h3 id="SPI的设计目标"><a href="#SPI的设计目标" class="headerlink" title="SPI的设计目标"></a>SPI的设计目标</h3></li>
<li>面向对象的设计里，模块之间基于接口编程，模块之间不对实现类进行硬编码（硬编码：数据直接嵌入到程序）</li>
<li>一旦代码涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码</li>
<li>为了实现在模块中装配的时候，不在模块里写死代码，这就需要一种服务发现机制</li>
<li>为某个接口寻找服务实现的机制，有点类似IOC的思想，就是将装配的控制权转移到代码之外<h3 id="SPI的具体约定"><a href="#SPI的具体约定" class="headerlink" title="SPI的具体约定"></a>SPI的具体约定</h3></li>
<li>当服务的提供者（provide），提供了一个接口多种实现时，一般会在jar包的META_INF/services/目录下，创建该接口的同名文件，该文件里面的内容就是该服务接口的具体实现类的名称</li>
<li>当外部加载这个模块的时候，就能通过jar包的META_INF/services/目录的配置文件得到具体的实现类名，并加载实例化，完成模块的装配<h3 id="dubbo为什么不直接使用JDK的SPI？"><a href="#dubbo为什么不直接使用JDK的SPI？" class="headerlink" title="dubbo为什么不直接使用JDK的SPI？"></a>dubbo为什么不直接使用JDK的SPI？</h3></li>
<li>JDK标准的SPI会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源</li>
<li>dubbo的SPI增加了对扩展点IoC和AOP的支持，一个扩展点可以直接setter注入其他扩展点，JDK的SPI是没有的<h3 id="dubbo的SPI目的：获取一个实现类的对象"><a href="#dubbo的SPI目的：获取一个实现类的对象" class="headerlink" title="dubbo的SPI目的：获取一个实现类的对象"></a>dubbo的SPI目的：获取一个实现类的对象</h3>途径：ExtensionLoader.getExtension(String name)<br>实现路径：</li>
<li> getExtensionLoader（Class&lt; Type &gt; type）就是为该接口new 一个ExtensionLoader，然后缓存起来。</li>
<li> getAdaptiveExtension（） 获取一个扩展类，如果@Adaptive注解在类上就是一个装饰类；如果注解在方法上就是一个动态代理类，例如Protocol$Adaptive对象。</li>
<li> getExtension（String name） 获取一个指定对象。<h3 id="ExtensionLoader"><a href="#ExtensionLoader" class="headerlink" title="ExtensionLoader"></a>ExtensionLoader</h3>ExtensionLoader扩展点加载器，是扩展点的查找，校验，加载等核心逻辑的实现类，几乎所有特性都在这个类中实现<br>从ExtensionLoader.getExtensionLoader（Class&lt; Type &gt; type）讲起<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-----------------------ExtensionLoader.getExtensionLoader(Class&lt;T&gt; type)</span><br><span class="line">ExtensionLoader.getExtensionLoader(Container.class)</span><br><span class="line">  --&gt;this.type &#x3D; type;</span><br><span class="line">  --&gt;objectFactory &#x3D; (type &#x3D;&#x3D; ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">     --&gt;ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()</span><br><span class="line">       --&gt;this.type &#x3D; type;</span><br><span class="line">       --&gt;objectFactory &#x3D;null;</span><br></pre></td></tr></table></figure>
执行以上代码完成了2个属性的初始化，是每个一个ExtensionLoader都包含了的2个值type和objectFactory</li>
</ol>
<ul>
<li>Class&lt; ? &gt; type: 构造器 初始化要得到的接口名</li>
<li>ExtensionFactory objectFactory ：<br>1、构造器 初始化AdaptiveExtensionFactory[ SpiExtensionFactory, SpringExtensionFactory]<br>2、new一个ExtensionLoader存储在ConcurrentMap&lt; Class&lt; ? &gt;, ExtensionLoader&lt; ? &gt; &gt; EXTENSION_LOADERS<h3 id="关于objectFactory的一些细节"><a href="#关于objectFactory的一些细节" class="headerlink" title="关于objectFactory的一些细节"></a>关于objectFactory的一些细节</h3></li>
</ul>
<ol>
<li>objectFactory 就是ExtensionFactory ，也是通过ExtensionLoader.getExtensionLoader(ExtensionFactory.class)来实现，但objectFactory  = null;</li>
<li>objectFactory 的作用就是为dubbo的IOC提供所有对象<h2 id="3、SPI-与-API的区别"><a href="#3、SPI-与-API的区别" class="headerlink" title="3、SPI 与 API的区别"></a>3、SPI 与 API的区别</h2>API  （Application Programming Interface）</li>
</ol>
<ul>
<li>大多数情况下，都是实现方来制定接口并完成对接口的不同实现，调用方仅仅依赖却无权选择不同实现。<br>SPI (Service Provider Interface)</li>
<li>而如果是调用方来制定接口，实现方来针对接口来实现不同的实现。调用方来选择自己需要的实现方。<br><img src="/images/dubbo-2.png"><br>当我们选择在调用方和实现方中间引入接口。我们有三种选择：</li>
</ul>
<ol>
<li>接口位于实现方所在的包中</li>
<li>接口位于调用方所在的包中</li>
<li>接口位于独立的包中<h3 id="1-接口位于【调用方】所在的包中"><a href="#1-接口位于【调用方】所在的包中" class="headerlink" title="1. 接口位于【调用方】所在的包中"></a>1. 接口位于【调用方】所在的包中</h3>对于类似这种情况下接口，我们将其称为 SPI, SPI的规则如下：</li>
</ol>
<ul>
<li>概念上更依赖调用方。</li>
<li>组织上位于调用方所在的包中。</li>
<li>实现位于独立的包中。<br>常见的例子是：插件模式的插件。如：</li>
<li>数据库驱动 Driver</li>
<li>日志 Log</li>
<li>dubbo扩展点开发<h3 id="2-接口位于【实现方】所在的包中"><a href="#2-接口位于【实现方】所在的包中" class="headerlink" title="2. 接口位于【实现方】所在的包中"></a>2. 接口位于【实现方】所在的包中</h3>对于类似这种情况下的接口，我们将其称作为API，API的规则如下：</li>
<li>概念上更接近实现方。</li>
<li>组织上位于实现方所在的包中。<h3 id="3-接口位于独立的包中"><a href="#3-接口位于独立的包中" class="headerlink" title="3. 接口位于独立的包中"></a>3. 接口位于独立的包中</h3>如果一个“接口”在一个上下文是API，在另一个上下文是SPI，那么你就可以这么组织<br><img src="/images/dubbo-3.png"><h2 id="4、SPI机制的adaptive原理"><a href="#4、SPI机制的adaptive原理" class="headerlink" title="4、SPI机制的adaptive原理"></a>4、SPI机制的adaptive原理</h2>先来看一下adaptive的源码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span>  <span class="comment">//只能注解在类、接口、方法上面</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Adaptive &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="adaptive注解在类和方法上的区别"><a href="#adaptive注解在类和方法上的区别" class="headerlink" title="@adaptive注解在类和方法上的区别"></a>@adaptive注解在类和方法上的区别</h3></li>
</ul>
<ol>
<li>注解在类上：代表人工实现编码，即实现了一个装饰类（设计模式中的装饰模式），例如：ExtensionFactory</li>
<li>注解在方法上：代表自动生成和编译一个动态的adpative类，例如：Protocol$adpative<br>再来看生成Protocol的源码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class)</span><br><span class="line">            .getAdaptiveExtension();</span><br></pre></td></tr></table></figure>
进入getAdaptiveExtension()，进行代码跟踪与解析<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-----------------------getAdaptiveExtension()</span><br><span class="line"> --&gt;getAdaptiveExtension()   <span class="comment">//目的为  cachedAdaptiveInstance赋值</span></span><br><span class="line">   --&gt;createAdaptiveExtension()</span><br><span class="line">     --&gt;getAdaptiveExtension()</span><br><span class="line">       --&gt;getExtensionClasses()   <span class="comment">//目的为cachedClasses赋值</span></span><br><span class="line">         --&gt;loadExtensionClasses()  <span class="comment">//加载</span></span><br><span class="line">           --&gt;loadFile()  <span class="comment">//加载配置信息（主要是META_INF/services/下）</span></span><br><span class="line">      --&gt;createAdaptiveExtensionClass()  <span class="comment">//下面的调用有两个分支</span></span><br><span class="line">         <span class="comment">// *********** 分支1 *******************  在找到的类上有Adaptive注解</span></span><br><span class="line">        -&gt;getExtensionClasses()</span><br><span class="line">        　　　　　　-&gt;loadExtensionClasses()</span><br><span class="line">        　　　　　　　　-&gt;loadFile(extensionClasses, DUBBO_INTERNAL_DIRECTORY);</span><br><span class="line">          <span class="comment">// *********** 分支2 ******************* 在找到的类上没有Adaptive注解</span></span><br><span class="line">        --&gt;createAdaptiveExtensionClassCode()<span class="comment">//通过adaptive模板生成代码</span></span><br><span class="line">          --&gt;ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();<span class="comment">//编译</span></span><br><span class="line">          --&gt;compile(String code, ClassLoader classLoader) <span class="comment">//自动生成和编译一个动态的adpative类，这个类是个代理类</span></span><br><span class="line">       --&gt;injectExtension()<span class="comment">//作用：进入IOC的反转控制模式，实现了动态入注,这是 ExtensionFactory 类的作用之所在 </span></span><br></pre></td></tr></table></figure>
上述的调用中使用loadFile()加载配置信息，下面关于loadFile() 的一些细节：<h3 id="loadFile-的目的"><a href="#loadFile-的目的" class="headerlink" title="loadFile()的目的"></a>loadFile()的目的</h3>把配置文件META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol的内容存储在缓存变量里面,下面四种缓存变量：</li>
<li>cachedAdaptiveClass //如果这个类有Adaptive注解就赋值，而Protocol在这个环节是没有的</li>
<li>cachedWrapperClasses //只有当该class无Adaptive注解，并且构造函数包含目标接口（type），例如protocol里面的spi就只有ProtocolFilterWrapper、ProtocolListenerWrapper能命中</li>
<li>cachedActivates //剩下的类包含adaptive注解</li>
<li>cachedNames //剩下的类就存储在这里<br>getExtension() 方法执行逻辑：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-----------------------getExtension(String name)</span><br><span class="line">getExtension(String name) <span class="comment">//指定对象缓存在cachedInstances；get出来的对象wrapper对象，例如protocol就是ProtocolFilterWrapper和ProtocolListenerWrapper其中一个。</span></span><br><span class="line">  --&gt;createExtension(String name)</span><br><span class="line">    --&gt;getExtensionClasses()</span><br><span class="line">    --&gt;injectExtension(T instance)<span class="comment">//dubbo的IOC反转控制，就是从spi和spring里面提取对象赋值。</span></span><br><span class="line">      --&gt;objectFactory.getExtension(pt, property)</span><br><span class="line">        --&gt;SpiExtensionFactory.getExtension(type, name)</span><br><span class="line">          --&gt;ExtensionLoader.getExtensionLoader(type)</span><br><span class="line">          --&gt;loader.getAdaptiveExtension()</span><br><span class="line">        --&gt;SpringExtensionFactory.getExtension(type, name)</span><br><span class="line">          --&gt;context.getBean(name)</span><br><span class="line">    --&gt;injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance))<span class="comment">//AOP的简单设计</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
可以根据方法的调用得出dubbo的spi流程<br><img src="/images/dubbo-4.png"><br>adaptive动态编译使用的模板<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> &lt;扩展点接口所在包&gt;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> &lt;扩展点接口名&gt;$<span class="title">Adpative</span> <span class="keyword">implements</span> &lt;扩展点接口&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;有<span class="meta">@Adaptive</span>注解的接口方法&gt;(&lt;方法参数&gt;) &#123;</span><br><span class="line">        <span class="keyword">if</span>(是否有URL类型方法参数?) 使用该URL参数</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(是否有方法类型上有URL属性) 使用该URL属性</span><br><span class="line">        # &lt;else 在加载扩展点生成自适应扩展点类时抛异常，即加载扩展点失败！&gt;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(获取的URL == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">              根据<span class="meta">@Adaptive</span>注解上声明的Key的顺序，从URL获致Value，作为实际扩展点名。</span><br><span class="line">               如URL没有Value，则使用缺省扩展点实现。如没有扩展点， <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Fail to get extension&quot;</span>);</span><br><span class="line"> </span><br><span class="line">               在扩展点实现调用该方法，并返回结果。</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> &lt;有<span class="meta">@Adaptive</span>注解的接口方法&gt;(&lt;方法参数&gt;) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;is not adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
例如com.alibaba.dubbo.rpc.Protocol接口的动态编译根据模板生成的扩展类Protocol$Adpative为：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.rpc;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protocol</span>$<span class="title">Adpative</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;method public abstract int com.alibaba.dubbo.rpc.Protocol.getDefaultPort() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> com.alibaba.dubbo.rpc.<span class="function">Exporter <span class="title">export</span><span class="params">(Invoker invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;com.alibaba.dubbo.rpc.Invoker argument == null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (invoker.getUrl() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;com.alibaba.dubbo.rpc.Invoker argument getUrl() == null&quot;</span>);</span><br><span class="line">        com.alibaba.dubbo.common.URL url = invoker.getUrl();</span><br><span class="line">        String extName = (url.getProtocol() == <span class="keyword">null</span> ? <span class="string">&quot;dubbo&quot;</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(&quot;</span> + url.toString() + <span class="string">&quot;) use keys([protocol])&quot;</span>);</span><br><span class="line">        Protocol extension = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> com.alibaba.dubbo.rpc.<span class="function">Invoker <span class="title">refer</span><span class="params">(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg1;</span><br><span class="line">        String extName = (url.getProtocol() == <span class="keyword">null</span> ? <span class="string">&quot;dubbo&quot;</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(&quot;</span> + url.toString() + <span class="string">&quot;) use keys([protocol])&quot;</span>);</span><br><span class="line">        com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>1、获取某个SPI接口的adaptive实现类的规则是：</li>
</ol>
<ul>
<li>实现类的类上面有Adaptive注解的，那么这个类就是adaptive类</li>
<li>实现类的类上面没有Adaptive注解，但是在方法上有Adaptive注解，则会动态生成adaptive类<br>2、生成的动态类的编译类是：com.alibaba.dubbo.common.compiler.support.AdaptiveCompiler类<br>3、动态类的本质是可以做到一个SPI中的不同的Adaptive方法可以去调不同的SPI实现类去处理。使得程序的灵活性大大提高,这才是整套SPI设计的一个精华之所在。<h2 id="5、Dubbo的动态编译"><a href="#5、Dubbo的动态编译" class="headerlink" title="5、Dubbo的动态编译"></a>5、Dubbo的动态编译</h2><img src="/images/dubbo-5.png"><br>Compile接口定义：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;javassist&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; compile(String code, ClassLoader classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>@SPI(“javassist”)：表示如果没有配置，dubbo默认选用javassist编译源代码，Javassist是一款字节码编辑工具,同时也是一个动态类库，它可以直接检查、修改以及创建 Java类。</li>
<li>接口方法compile第一个入参code，就是java的源代码</li>
<li>接口方法compile第二个入参classLoader，按理是类加载器用来加载编译后的字节码，其实没用到，都是根据当前线程或者调用方的classLoader加载的<br>AdaptiveCompiler是Compiler的设配类，它的作用是Compiler策略的选择，根据条件选择使用何种编译策略来编译动态生成SPI扩展 ，默认为javassist.<br>AbstractCompiler是一个抽象类，它通过正则表达式获取到对象的包名以及Class名称。这样就可以获取对象的全类名(包名+Class名称)。通过反射Class.forName()来判断当前ClassLoader是否有这个类，如果有就返回，如果没有就通过JdkCompiler或者JavassistCompiler通过传入的code编译这个类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure></li>
<li>getExtensionLoader()：new一个ExtensionLoader对象，用到单例模式、工厂模式，然后换成起来。</li>
<li>getAdaptiveExtension()：为了获取扩展装饰类或代理类的对像，不过有个规则：如果@Adaptive注解在类上就是一个装饰类；如果注解在方法上就是一个动态代理类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCompiler</span> <span class="keyword">implements</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PACKAGE_PATTERN = Pattern.compile(<span class="string">&quot;package\\s+([$_a-zA-Z][$_a-zA-Z0-9\\.]*);&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern CLASS_PATTERN = Pattern.compile(<span class="string">&quot;class\\s+([$_a-zA-Z][$_a-zA-Z0-9]*)\\s+&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; compile(String code, ClassLoader classLoader) &#123;</span><br><span class="line">        code = code.trim();</span><br><span class="line">        Matcher matcher = PACKAGE_PATTERN.matcher(code);<span class="comment">//包名  </span></span><br><span class="line">        String pkg;</span><br><span class="line">        <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">            pkg = matcher.group(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pkg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        matcher = CLASS_PATTERN.matcher(code);<span class="comment">//类名  </span></span><br><span class="line">        String cls;</span><br><span class="line">        <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">            cls = matcher.group(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;No such class name in &quot;</span> + code);</span><br><span class="line">        &#125;</span><br><span class="line">        String className = pkg != <span class="keyword">null</span> &amp;&amp; pkg.length() &gt; <span class="number">0</span> ? pkg + <span class="string">&quot;.&quot;</span> + cls : cls;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Class.forName(className, <span class="keyword">true</span>, ClassHelper.getCallerClassLoader(getClass()));<span class="comment">//根据类全路径来查找类  </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!code.endsWith(<span class="string">&quot;&#125;&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The java code not endsWith \&quot;&#125;\&quot;, code: \n&quot;</span> + code + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> doCompile(className, code);<span class="comment">//调用实现类JavassistCompiler或JdkCompiler的doCompile方法来动态编译类  </span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException t) &#123;</span><br><span class="line">                <span class="keyword">throw</span> t;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to compile class, cause: &quot;</span> + t.getMessage() + <span class="string">&quot;, class: &quot;</span> + className + <span class="string">&quot;, code: \n&quot;</span> + code + <span class="string">&quot;\n, stack: &quot;</span> + ClassUtils.toString(t));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;?&gt; doCompile(String name, String source) <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
AbstractCompiler：在公用逻辑中，利用正则表达式匹配出源代码中的包名和类名： </li>
<li>PACKAGE_PATTERN = Pattern.compile(“package\s+([$_a-zA-Z][$_a-zA-Z0-9\.]*);”); </li>
<li>CLASS_PATTERN = Pattern.compile(“class\s+([$_a-zA-Z][$_a-zA-Z0-9]*)\s+”);<br>然后在JVM中查找看看是否存在：Class.forName(className, true, ClassHelper.getCallerClassLoader(getClass()));存在返回，不存在就使用JavassistCompiler或者是JdkCompiler来执行编译。 <h2 id="6、dubbo和spring完美融合"><a href="#6、dubbo和spring完美融合" class="headerlink" title="6、dubbo和spring完美融合"></a>6、dubbo和spring完美融合</h2>dubbo采取通过配置文件来启动container容器，dubbo是使用spring来做容器<br>dubbo实现通过下面的配置schema自定义配置<br><img src="/images/dubbo-6.png"></li>
</ul>
<p><strong>完成一个spring的自定义配置一般需要以下5个步骤：</strong></p>
<ol>
<li>设计配置属性和JavaBean</li>
<li>编写XSD文件 全称就是 XML Schema  它就是校验XML，定义了一些列的语法来规范XML</li>
<li>编写NamespaceHandler和BeanDefinitionParser完成解析工作</li>
<li>编写两个类spring.handlers和spring.schemas串联起所有部件</li>
<li>在Bean文件中应用<h3 id="1-设计配置属性和JavaBean"><a href="#1-设计配置属性和JavaBean" class="headerlink" title="1. 设计配置属性和JavaBean"></a>1. 设计配置属性和JavaBean</h3>先配置属性dubbo.xml，可以看出一个service对象，有属性包括，interface、ref等<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 和本地bean一样实现服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.alibaba.dubbo.demo.DemoService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-编写XSD文件-全称就是-XML-Schema-它就是校验XML，定义了一些列的语法来规范XML"><a href="#2-编写XSD文件-全称就是-XML-Schema-它就是校验XML，定义了一些列的语法来规范XML" class="headerlink" title="2. 编写XSD文件 全称就是 XML Schema  它就是校验XML，定义了一些列的语法来规范XML"></a>2. 编写XSD文件 全称就是 XML Schema  它就是校验XML，定义了一些列的语法来规范XML</h3>下面是dubbo.xsd文件,作用是约束interface和ref属性，比如ref只能是string类，输入其他类型就提示报错<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;service&quot;</span> <span class="attr">type</span>=<span class="string">&quot;serviceType&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>&lt;![CDATA[ Export service config ]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">xsd:complexType</span> <span class="attr">name</span>=<span class="string">&quot;serviceType&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">xsd:complexContent</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">xsd:extension</span> <span class="attr">base</span>=<span class="string">&quot;abstractServiceType&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">xsd:choice</span> <span class="attr">minOccurs</span>=<span class="string">&quot;0&quot;</span> <span class="attr">maxOccurs</span>=<span class="string">&quot;unbounded&quot;</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">ref</span>=<span class="string">&quot;method&quot;</span> <span class="attr">minOccurs</span>=<span class="string">&quot;0&quot;</span> <span class="attr">maxOccurs</span>=<span class="string">&quot;unbounded&quot;</span>/&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">ref</span>=<span class="string">&quot;parameter&quot;</span> <span class="attr">minOccurs</span>=<span class="string">&quot;0&quot;</span> <span class="attr">maxOccurs</span>=<span class="string">&quot;unbounded&quot;</span>/&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">ref</span>=<span class="string">&quot;beans:property&quot;</span> <span class="attr">minOccurs</span>=<span class="string">&quot;0&quot;</span> <span class="attr">maxOccurs</span>=<span class="string">&quot;unbounded&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">xsd:choice</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;interface&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:token&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">                           &lt;![CDATA[ Defines the interface to advertise for this service in the service registry. ]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">xsd:appinfo</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">tool:annotation</span>&gt;</span></span><br><span class="line">                               <span class="tag">&lt;<span class="name">tool:expected-type</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.Class&quot;</span>/&gt;</span></span><br><span class="line">                           <span class="tag">&lt;/<span class="name">tool:annotation</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">xsd:appinfo</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">xsd:attribute</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;ref&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span> <span class="attr">use</span>=<span class="string">&quot;optional&quot;</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">                           &lt;![CDATA[ The service implementation instance bean id. ]]&gt;<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">xsd:attribute</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">xsd:extension</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">xsd:complexContent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-编写NamespaceHandler和BeanDefinitionParser完成解析工作"><a href="#3-编写NamespaceHandler和BeanDefinitionParser完成解析工作" class="headerlink" title="3. 编写NamespaceHandler和BeanDefinitionParser完成解析工作"></a>3. 编写NamespaceHandler和BeanDefinitionParser完成解析工作</h3>DubboNamespaceHandler这个类是个处理器，初始化时将各种bean注册到解析器上，将配置文件的值赋值到bean上<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;application&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ApplicationConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;module&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ModuleConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;registry&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(RegistryConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;monitor&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MonitorConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;provider&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProviderConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;consumer&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConsumerConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;protocol&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProtocolConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;service&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ServiceBean.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;reference&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ReferenceBean.class, <span class="keyword">false</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;annotation&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(AnnotationBean.class, <span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
解析器DubboBeanDefinitionParser，代码太长就不贴了，解析器大概作用：从配置文件中通过element.getAttribute(String name)拿到属性的值，赋给bean。<br>​<br>​<br>那么问题来了，dubbo.xsd和DubboNamespaceHandler 、DubboBeanDefinitionParser 这两个类是关联起来呢？第四步来解决这个问题<h3 id="4-编写两个类spring-handlers和spring-schemas串联起所有部件"><a href="#4-编写两个类spring-handlers和spring-schemas串联起所有部件" class="headerlink" title="4. 编写两个类spring.handlers和spring.schemas串联起所有部件"></a>4. 编写两个类spring.handlers和spring.schemas串联起所有部件</h3>最后也是通过两个类spring.handlers和spring.schemas串联起所有部件<br>spring.handlers<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\://code.alibabatech.com/schema/dubbo=com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler</span><br></pre></td></tr></table></figure>
spring.schemas<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\://code.alibabatech.com/schema/dubbo/dubbo.xsd=META-INF/dubbo.xsd</span><br></pre></td></tr></table></figure>
<h3 id="5-在Bean文件中应用"><a href="#5-在Bean文件中应用" class="headerlink" title="5. 在Bean文件中应用"></a>5. 在Bean文件中应用</h3><h2 id="7、服务发布过程"><a href="#7、服务发布过程" class="headerlink" title="7、服务发布过程"></a>7、服务发布过程</h2>启动服务提供者的时候通过打印出来的日志知道整个服务发现流程：<br>第一个发布的动作：暴露本地服务<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Export dubbo service com.alibaba.dubbo.demo.DemoService to local registry, dubbo version: 2.0.0, current host: 127.0.0.1</span><br></pre></td></tr></table></figure>
第二个发布动作：暴露远程服务<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Export dubbo service com.alibaba.dubbo.demo.DemoService to url dubbo://192.168.100.38:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=roundrobin&amp;methods=sayHello&amp;owner=william&amp;pid=8484&amp;side=provider&amp;timestamp=1473908495465, dubbo version: 2.0.0, current host: 127.0.0.1</span><br><span class="line">Register dubbo service com.alibaba.dubbo.demo.DemoService url dubbo://192.168.100.38:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=roundrobin&amp;methods=sayHello&amp;monitor=dubbo%3A%2F%2F192.168.48.117%3A2181%2Fcom.alibaba.dubbo.registry.RegistryService%3Fapplication%3Ddemo-provider%26backup%3D192.168.48.120%3A2181%2C192.168.48.123%3A2181%26dubbo%3D2.0.0%26owner%3Dwilliam%26pid%3D8484%26protocol%3Dregistry%26refer%3Ddubbo%253D2.0.0%2526interface%253Dcom.alibaba.dubbo.monitor.MonitorService%2526pid%253D8484%2526timestamp%253D1473908495729%26registry%3Dzookeeper%26timestamp%3D1473908495398&amp;owner=william&amp;pid=8484&amp;side=provider&amp;timestamp=1473908495465 to registry registry://192.168.48.117:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;backup=192.168.48.120:2181,192.168.48.123:2181&amp;dubbo=2.0.0&amp;owner=william&amp;pid=8484&amp;registry=zookeeper&amp;timestamp=1473908495398, dubbo version: 2.0.0, current host: 127.0.0.1</span><br></pre></td></tr></table></figure>
第三个发布动作：启动netty<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Start NettyServer bind /0.0.0.0:20880, export /192.168.100.38:20880, dubbo version: 2.0.0, current host: 127.0.0.1</span><br></pre></td></tr></table></figure>
第四个发布动作：打开连接zk<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO zookeeper.ClientCnxn: Opening socket connection to server /192.168.48.117:2181</span><br></pre></td></tr></table></figure>
第五个发布动作：到zk注册<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Register: dubbo://192.168.100.38:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=roundrobin&amp;methods=sayHello&amp;owner=william&amp;pid=8484&amp;side=provider&amp;timestamp=1473908495465, dubbo version: 2.0.0, current host: 127.0.0.1</span><br></pre></td></tr></table></figure>
第六个发布动作；监听zk<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Subscribe: provider://192.168.100.38:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;category=configurators&amp;check=false&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=roundrobin&amp;methods=sayHello&amp;owner=william&amp;pid=8484&amp;side=provider&amp;timestamp=1473908495465, dubbo version: 2.0.0, current host: 127.0.0.1</span><br><span class="line">Notify urls for subscribe url provider://192.168.100.38:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;category=configurators&amp;check=false&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=roundrobin&amp;methods=sayHello&amp;owner=william&amp;pid=8484&amp;side=provider&amp;timestamp=1473908495465, urls: [empty://192.168.100.38:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;category=configurators&amp;check=false&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=roundrobin&amp;methods=sayHello&amp;owner=william&amp;pid=8484&amp;side=provider&amp;timestamp=1473908495465], dubbo version: 2.0.0, current host: 127.0.0.1</span><br></pre></td></tr></table></figure>
<h3 id="暴露本地服务和暴露远程服务的区别是什么？"><a href="#暴露本地服务和暴露远程服务的区别是什么？" class="headerlink" title="暴露本地服务和暴露远程服务的区别是什么？"></a>暴露本地服务和暴露远程服务的区别是什么？</h3></li>
<li>暴露本地服务：指暴露在用一个JVM里面，不用通过调用zk来进行远程通信。例如：在同一个服务，自己调用自己的接口，就没必要进行网络IP连接来通信。</li>
<li>暴露远程服务：指暴露给远程客户端的IP和端口号，通过网络来实现通信。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">ServiceBean.onApplicationEvent</span><br><span class="line">--&gt;export()</span><br><span class="line">  --&gt;ServiceConfig.export()</span><br><span class="line">    --&gt;doExport()</span><br><span class="line">      --&gt;doExportUrls()<span class="comment">//里面有一个for循环，代表了一个服务可以有多个通信协议，例如 tcp协议 http协议，默认是tcp协议</span></span><br><span class="line">        --&gt;loadRegistries(<span class="keyword">true</span>)<span class="comment">//从dubbo.properties里面组装registry的url信息</span></span><br><span class="line">        --&gt;doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) </span><br><span class="line">          <span class="comment">//配置不是remote的情况下做本地暴露 (配置为remote，则表示只暴露远程服务)</span></span><br><span class="line">          --&gt;exportLocal(URL url)</span><br><span class="line">            --&gt;proxyFactory.getInvoker(ref, (Class) interfaceClass, local)</span><br><span class="line">              --&gt;ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(<span class="string">&quot;javassist&quot;</span>);</span><br><span class="line">              --&gt;extension.getInvoker(arg0, arg1, arg2)</span><br><span class="line">                --&gt;StubProxyFactoryWrapper.getInvoker(T proxy, Class&lt;T&gt; type, URL url) </span><br><span class="line">                  --&gt;proxyFactory.getInvoker(proxy, type, url)</span><br><span class="line">                    --&gt;JavassistProxyFactory.getInvoker(T proxy, Class&lt;T&gt; type, URL url)</span><br><span class="line">                      --&gt;Wrapper.getWrapper(com.alibaba.dubbo.demo.provider.DemoServiceImpl)</span><br><span class="line">                        --&gt;makeWrapper(Class&lt;?&gt; c)</span><br><span class="line">                      --&gt;<span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url)</span><br><span class="line">            --&gt;protocol.export</span><br><span class="line">              --&gt;Protocol$Adpative.export</span><br><span class="line">                --&gt;ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(<span class="string">&quot;injvm&quot;</span>);</span><br><span class="line">                --&gt;extension.export(arg0)</span><br><span class="line">                  --&gt;ProtocolFilterWrapper.export</span><br><span class="line">                    --&gt;buildInvokerChain <span class="comment">//创建8个filter</span></span><br><span class="line">                    --&gt;ProtocolListenerWrapper.export</span><br><span class="line">                      --&gt;InjvmProtocol.export</span><br><span class="line">                        --&gt;<span class="keyword">return</span> <span class="keyword">new</span> InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap)</span><br><span class="line">                        --&gt;目的：exporterMap.put(key, <span class="keyword">this</span>)<span class="comment">//key=com.alibaba.dubbo.demo.DemoService, this=InjvmExporter</span></span><br><span class="line">          <span class="comment">//如果配置不是local则暴露为远程服务.(配置为local，则表示只暴露本地服务)</span></span><br><span class="line">          --&gt;proxyFactory.getInvoker<span class="comment">//原理和本地暴露一样都是为了获取一个Invoker对象</span></span><br><span class="line">          --&gt;protocol.export(invoker)</span><br><span class="line">            --&gt;Protocol$Adpative.export</span><br><span class="line">              --&gt;ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(<span class="string">&quot;registry&quot;</span>);</span><br><span class="line">	            --&gt;extension.export(arg0)</span><br><span class="line">	              --&gt;ProtocolFilterWrapper.export</span><br><span class="line">	                --&gt;ProtocolListenerWrapper.export</span><br><span class="line">	                  --&gt;RegistryProtocol.export</span><br><span class="line">	                    --&gt;doLocalExport(originInvoker)</span><br><span class="line">	                      --&gt;getCacheKey(originInvoker);<span class="comment">//读取 dubbo://192.168.100.51:20880/</span></span><br><span class="line">	                      --&gt;rotocol.export</span><br><span class="line">	                        --&gt;Protocol$Adpative.export</span><br><span class="line">	                          --&gt;ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(<span class="string">&quot;dubbo&quot;</span>);</span><br><span class="line">	                          --&gt;extension.export(arg0)</span><br><span class="line">	                            --&gt;ProtocolFilterWrapper.export</span><br><span class="line">	                              --&gt;buildInvokerChain<span class="comment">//创建8个filter</span></span><br><span class="line">	                              --&gt;ProtocolListenerWrapper.export</span><br><span class="line">---------<span class="number">1.</span>netty服务暴露的开始-------    --&gt;DubboProtocol.export</span><br><span class="line">	                                  --&gt;serviceKey(url)<span class="comment">//组装key=com.alibaba.dubbo.demo.DemoService:20880</span></span><br><span class="line">	                                  --&gt;目的：exporterMap.put(key, <span class="keyword">this</span>)<span class="comment">//key=com.alibaba.dubbo.demo.DemoService:20880, this=DubboExporter</span></span><br><span class="line">	                                  --&gt;openServer(url)</span><br><span class="line">	                                    --&gt;createServer(url)</span><br><span class="line">--------<span class="number">2.</span>信息交换层 exchanger 开始--------------&gt;Exchangers.bind(url, requestHandler)<span class="comment">//exchaanger是一个信息交换层</span></span><br><span class="line">	                                        --&gt;getExchanger(url)</span><br><span class="line">	                                          --&gt;getExchanger(type)</span><br><span class="line">	                                            --&gt;ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(<span class="string">&quot;header&quot;</span>)</span><br><span class="line">	                                        --&gt;HeaderExchanger.bind</span><br><span class="line">	                                          --&gt;Transporters.bind(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler)))</span><br><span class="line">	                                            --&gt;<span class="keyword">new</span> HeaderExchangeHandler(handler)<span class="comment">//this.handler = handler</span></span><br><span class="line">	                                            --&gt;<span class="keyword">new</span> DecodeHandler</span><br><span class="line">	                                            	--&gt;<span class="keyword">new</span> AbstractChannelHandlerDelegate<span class="comment">//this.handler = handler;</span></span><br><span class="line">---------<span class="number">3.</span>网络传输层 transporter---------------------&gt;Transporters.bind</span><br><span class="line">	                                              --&gt;getTransporter()</span><br><span class="line">	                                                --&gt;ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension()</span><br><span class="line">	                                              --&gt;Transporter$Adpative.bind</span><br><span class="line">	                                                --&gt;ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.remoting.Transporter.class).getExtension(<span class="string">&quot;netty&quot;</span>);</span><br><span class="line">	                                                --&gt;extension.bind(arg0, arg1)</span><br><span class="line">	                                                  --&gt;NettyTransporter.bind</span><br><span class="line">	                                                    --<span class="keyword">new</span> NettyServer(url, listener)</span><br><span class="line">	                                                      --&gt;AbstractPeer <span class="comment">//this.url = url;    this.handler = handler;</span></span><br><span class="line">	                                                      --&gt;AbstractEndpoint<span class="comment">//codec  timeout=1000  connectTimeout=3000</span></span><br><span class="line">	                                                      --&gt;AbstractServer <span class="comment">//bindAddress accepts=0 idleTimeout=600000</span></span><br><span class="line">---------<span class="number">4.</span>打开断开，暴露netty服务--------------------------------&gt;doOpen()</span><br><span class="line">	                                                        --&gt;设置 NioServerSocketChannelFactory boss worker的线程池 线程个数为<span class="number">3</span></span><br><span class="line">	                                                        --&gt;设置编解码 hander</span><br><span class="line">	                                                        --&gt;bootstrap.bind(getBindAddress())</span><br><span class="line">	                                            --&gt;<span class="keyword">new</span> HeaderExchangeServer</span><br><span class="line">	                                              --&gt;<span class="keyword">this</span>.server=NettyServer</span><br><span class="line">	                                              --&gt;heartbeat=<span class="number">60000</span></span><br><span class="line">	                                              --&gt;heartbeatTimeout=<span class="number">180000</span></span><br><span class="line">	                                              --&gt;startHeatbeatTimer()<span class="comment">//这是一个心跳定时器，采用了线程池，如果断开就心跳重连。</span></span><br><span class="line">	                    --&gt;getRegistry(originInvoker)<span class="comment">//zk 连接</span></span><br><span class="line">	                      --&gt;registryFactory.getRegistry(registryUrl)</span><br><span class="line">	                        --&gt;ExtensionLoader.getExtensionLoader(RegistryFactory.class).getExtension(<span class="string">&quot;zookeeper&quot;</span>);</span><br><span class="line">	                        --&gt;extension.getRegistry(arg0)</span><br><span class="line">	                          --&gt;AbstractRegistryFactory.getRegistry<span class="comment">//创建一个注册中心，存储在REGISTRIES</span></span><br><span class="line">	                            --&gt;createRegistry(url)</span><br><span class="line">	                              --&gt;<span class="keyword">new</span> ZookeeperRegistry(url, zookeeperTransporter)</span><br><span class="line">	                                --&gt;AbstractRegistry</span><br><span class="line">	                                  --&gt;loadProperties()<span class="comment">//目的：把C:\Users\bobo\.dubbo\dubbo-registry-192.168.48.117.cache</span></span><br><span class="line">	                                                                                                                                                                    文件中的内容加载为properties</span><br><span class="line">	                                  --&gt;notify(url.getBackupUrls())<span class="comment">//不做任何事             </span></span><br><span class="line">	                                --&gt;FailbackRegistry   </span><br><span class="line">	                                  --&gt;retryExecutor.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable()<span class="comment">//建立线程池，检测并连接注册中心,如果失败了就重连</span></span><br><span class="line">	                                --&gt;ZookeeperRegistry</span><br><span class="line">	                                  --&gt;zookeeperTransporter.connect(url)</span><br><span class="line">	                                    --&gt;ZookeeperTransporter$Adpative.connect(url)</span><br><span class="line">	                                      --&gt;ExtensionLoader.getExtensionLoader(ZookeeperTransporter.class).getExtension(<span class="string">&quot;zkclient&quot;</span>);</span><br><span class="line">	                                      --&gt;extension.connect(arg0)</span><br><span class="line">	                                        --&gt;ZkclientZookeeperTransporter.connect</span><br><span class="line">	                                          --&gt;<span class="keyword">new</span> ZkclientZookeeperClient(url)</span><br><span class="line">	                                            --&gt;AbstractZookeeperClient</span><br><span class="line">	                                            --&gt;ZkclientZookeeperClient</span><br><span class="line">	                                              --&gt;<span class="keyword">new</span> ZkClient(url.getBackupAddress());<span class="comment">//连接ZK</span></span><br><span class="line">	                                              --&gt;client.subscribeStateChanges(<span class="keyword">new</span> IZkStateListener()<span class="comment">//订阅的目标：连接断开，重连</span></span><br><span class="line">	                                    --&gt;zkClient.addStateListener(<span class="keyword">new</span> StateListener() </span><br><span class="line">	                                      --&gt;recover <span class="comment">//连接失败 重连</span></span><br><span class="line">	                                      </span><br><span class="line">	                    --&gt;registry.register(registedProviderUrl)<span class="comment">//创建节点</span></span><br><span class="line">	                      --&gt;AbstractRegistry.register</span><br><span class="line">	                      --&gt;FailbackRegistry.register</span><br><span class="line">	                        --&gt;doRegister(url)<span class="comment">//向zk服务器端发送注册请求</span></span><br><span class="line">	                          --&gt;ZookeeperRegistry.doRegister</span><br><span class="line">	                            --&gt;zkClient.create</span><br><span class="line">	                              --&gt;AbstractZookeeperClient.create<span class="comment">//dubbo/com.alibaba.dubbo.demo.DemoService/providers/</span></span><br><span class="line">										                              dubbo%3A%<span class="number">2F</span>%2F192<span class="number">.168</span><span class="number">.100</span><span class="number">.52</span>%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%<span class="number">26</span></span><br><span class="line">										                              application%3Ddemo-provider%26dubbo%3D2<span class="number">.0</span><span class="number">.0</span>%26generic%3Dfalse%26interface%<span class="number">3D</span></span><br><span class="line">										                              com.alibaba.dubbo.demo.DemoService%26loadbalance%3Droundrobin%26methods%3DsayHello%26owner%<span class="number">3</span></span><br><span class="line">										                              Dwilliam%26pid%3D2416%26side%3Dprovider%26timestamp%3D1474276306353</span><br><span class="line">	                                --&gt;createEphemeral(path);<span class="comment">//临时节点  dubbo%3A%2F%2F192.168.100.52%3A20880%2F.............</span></span><br><span class="line">	                                --&gt;createPersistent(path);<span class="comment">//持久化节点 dubbo/com.alibaba.dubbo.demo.DemoService/providers</span></span><br><span class="line">	                                    </span><br><span class="line">	                                    </span><br><span class="line">	                    --&gt;registry.subscribe<span class="comment">//订阅ZK</span></span><br><span class="line">	                      --&gt;AbstractRegistry.subscribe</span><br><span class="line">	                      --&gt;FailbackRegistry.subscribe</span><br><span class="line">	                        --&gt;doSubscribe(url, listener)<span class="comment">// 向服务器端发送订阅请求</span></span><br><span class="line">	                          --&gt;ZookeeperRegistry.doSubscribe</span><br><span class="line">	                            --&gt;<span class="keyword">new</span> ChildListener()</span><br><span class="line">	                              --&gt;实现了 childChanged</span><br><span class="line">	                                --&gt;实现并执行 ZookeeperRegistry.<span class="keyword">this</span>.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds));</span><br><span class="line">	                              <span class="comment">//A</span></span><br><span class="line">	                            --&gt;zkClient.create(path, <span class="keyword">false</span>);<span class="comment">//第一步：先创建持久化节点/dubbo/com.alibaba.dubbo.demo.DemoService/configurators</span></span><br><span class="line">	                            --&gt;zkClient.addChildListener(path, zkListener)</span><br><span class="line">	                              --&gt;AbstractZookeeperClient.addChildListener</span><br><span class="line">	                                <span class="comment">//C</span></span><br><span class="line">	                                --&gt;createTargetChildListener(path, listener)<span class="comment">//第三步：收到订阅后的处理，交给FailbackRegistry.notify处理</span></span><br><span class="line">	                                  --&gt;ZkclientZookeeperClient.createTargetChildListener</span><br><span class="line">	                                    --&gt;<span class="keyword">new</span> IZkChildListener() </span><br><span class="line">	                                      --&gt;实现了 handleChildChange <span class="comment">//收到订阅后的处理</span></span><br><span class="line">	                                      	--&gt;listener.childChanged(parentPath, currentChilds);</span><br><span class="line">	                                      	--&gt;实现并执行ZookeeperRegistry.<span class="keyword">this</span>.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds));</span><br><span class="line">	                                      	--&gt;收到订阅后处理 FailbackRegistry.notify</span><br><span class="line">	                                <span class="comment">//B      	</span></span><br><span class="line">	                                --&gt;addTargetChildListener(path, targetListener)<span class="comment">////第二步</span></span><br><span class="line">	                                  --&gt;ZkclientZookeeperClient.addTargetChildListener</span><br><span class="line">	                                    --&gt;client.subscribeChildChanges(path, listener)<span class="comment">//第二步：启动加入订阅/dubbo/com.alibaba.dubbo.demo.DemoService/configurators</span></span><br><span class="line">	                    </span><br><span class="line">	                    --&gt;notify(url, listener, urls)</span><br><span class="line">	                      --&gt;FailbackRegistry.notify</span><br><span class="line">	                        --&gt;doNotify(url, listener, urls);</span><br><span class="line">	                          --&gt;AbstractRegistry.notify</span><br><span class="line">	                            --&gt;saveProperties(url);<span class="comment">//把服务端的注册url信息更新到C:\Users\bobo\.dubbo\dubbo-registry-192.168.48.117.cache</span></span><br><span class="line">	                              --&gt;registryCacheExecutor.execute(<span class="keyword">new</span> SaveProperties(version));<span class="comment">//采用线程池来处理</span></span><br><span class="line">	                            --&gt;listener.notify(categoryList)</span><br><span class="line">	                              --&gt;RegistryProtocol.notify</span><br><span class="line">	                                --&gt;RegistryProtocol.<span class="keyword">this</span>.getProviderUrl(originInvoker)<span class="comment">//通过invoker的url 获取 providerUrl的地址</span></span><br></pre></td></tr></table></figure>
<h3 id="服务发布整体架构设计图"><a href="#服务发布整体架构设计图" class="headerlink" title="服务发布整体架构设计图"></a>服务发布整体架构设计图</h3><img src="/images/dubbo-7.png"><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3>1、proxyFactory：为了获取一个接口的代理类，例如获取一个远程接口的代理<br>它有2个方法，代表2个作用：</li>
<li>getInvoker（）：针对server端，将服务对象，如DemoServiceImpl包装成一个Invoker对象</li>
<li>getProxy（）：针对client端，创建接口的代理对象，例如DemoService的接口<br>2、Wrapper：它类似spring的beanWrapper，它就是包装了一个接口或一个类，可以通过wrapper对实例对象进行赋值以及制定方法的调用<br>3、Invoker：一个可执行的对象，能够根据方法的名称、参数得到相应的执行结果。<br>它里面有一个很重要的方法Result invoke（Invocation invocation），Invocation是包含了需要执行的方法和参数等重要信息，目前只有两个实现类。RpcInvocation 、MockInvocation<br>它有三种类型的Invoker：</li>
<li>本地执行的Invoker  </li>
<li>远程通信的Invoker  </li>
<li>多个远程通信执行类的Invoker聚合成集群版的Invoker<br>4、Protocol</li>
<li>export:暴露远程服务（用于服务端），就是将proxyFactory.getInvoker创建的代理类invoker对象，通过协议暴露给外部</li>
<li>refer：引用远程服务（用于客户端），通过proxyFactory.getProxy来创建远程的动态代理类，例如DemoDemoService的接口<br>5、exporter：维护invoder的生命周期<br>6、exchanger：信息交换层，封装请求相应模式，同步转异步<br>7、transporter：网络传输层，用来抽象netty和mina的统一接口<br>​<br>​<br>​<br>​<br>​<br>​    <h2 id="8、服务调用过程"><a href="#8、服务调用过程" class="headerlink" title="8、服务调用过程"></a>8、服务调用过程</h2>下面是服务引用详细的代码跟踪与解析<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">ReferenceBean.getObject()</span><br><span class="line">  --&gt;ReferenceConfig.get()</span><br><span class="line">    --&gt;init()</span><br><span class="line">      --&gt;createProxy(map)</span><br><span class="line">        --&gt;refprotocol.refer(interfaceClass, urls.get(<span class="number">0</span>))</span><br><span class="line">          --&gt;ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(<span class="string">&quot;registry&quot;</span>);</span><br><span class="line">          --&gt;extension.refer(arg0, arg1);</span><br><span class="line">            --&gt;ProtocolFilterWrapper.refer</span><br><span class="line">              --&gt;RegistryProtocol.refer</span><br><span class="line">                --&gt;registryFactory.getRegistry(url)<span class="comment">//建立zk的连接，和服务端发布一样（省略代码）</span></span><br><span class="line">                --&gt;doRefer(cluster, registry, type, url)</span><br><span class="line">                  --&gt;registry.register<span class="comment">//创建zk的节点，和服务端发布一样（省略代码）。节点名为：dubbo/com.alibaba.dubbo.demo.DemoService/consumers</span></span><br><span class="line">                  --&gt;registry.subscribe<span class="comment">//订阅zk的节点，和服务端发布一样（省略代码）。   /dubbo/com.alibaba.dubbo.demo.DemoService/providers, </span></span><br><span class="line">                                                                        /dubbo/com.alibaba.dubbo.demo.DemoService/configurators,</span><br><span class="line">                                                                         /dubbo/com.alibaba.dubbo.demo.DemoService/routers]</span><br><span class="line">                    --&gt;notify(url, listener, urls);</span><br><span class="line">                      --&gt;FailbackRegistry.notify</span><br><span class="line">                        --&gt;doNotify(url, listener, urls);</span><br><span class="line">                          --&gt;AbstractRegistry.notify</span><br><span class="line">                            --&gt;saveProperties(url);<span class="comment">//把服务端的注册url信息更新到C:\Users\bobo\.dubbo\dubbo-registry-192.168.48.117.cache</span></span><br><span class="line">	                          --&gt;registryCacheExecutor.execute(<span class="keyword">new</span> SaveProperties(version));<span class="comment">//采用线程池来处理</span></span><br><span class="line">	                        --&gt;listener.notify(categoryList)</span><br><span class="line">	                          --&gt;RegistryDirectory.notify</span><br><span class="line">	                            --&gt;refreshInvoker(invokerUrls)<span class="comment">//刷新缓存中的invoker列表</span></span><br><span class="line">	                              --&gt;destroyUnusedInvokers(oldUrlInvokerMap,newUrlInvokerMap); <span class="comment">// 关闭未使用的Invoker</span></span><br><span class="line">	                              --&gt;最终目的：刷新Map&lt;String, Invoker&lt;T&gt;&gt; urlInvokerMap 对象</span><br><span class="line">	                                                                                                                       刷新Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; methodInvokerMap对象</span><br><span class="line">                  --&gt;cluster.join(directory)<span class="comment">//加入集群路由</span></span><br><span class="line">                    --&gt;ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.cluster.Cluster.class).getExtension(<span class="string">&quot;failover&quot;</span>);</span><br><span class="line">                      --&gt;MockClusterWrapper.join</span><br><span class="line">                        --&gt;<span class="keyword">this</span>.cluster.join(directory)</span><br><span class="line">                          --&gt;FailoverCluster.join</span><br><span class="line">                            --&gt;<span class="keyword">return</span> <span class="keyword">new</span> FailoverClusterInvoker&lt;T&gt;(directory)</span><br><span class="line">                            --&gt;<span class="keyword">new</span> MockClusterInvoker</span><br><span class="line">        --&gt;proxyFactory.getProxy(invoker)<span class="comment">//创建服务代理</span></span><br><span class="line">          --&gt;ProxyFactory$Adpative.getProxy</span><br><span class="line">            --&gt;ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(<span class="string">&quot;javassist&quot;</span>);</span><br><span class="line">              --&gt;StubProxyFactoryWrapper.getProxy</span><br><span class="line">                --&gt;proxyFactory.getProxy(invoker)</span><br><span class="line">                  --&gt;AbstractProxyFactory.getProxy</span><br><span class="line">                    --&gt;getProxy(invoker, interfaces)</span><br><span class="line">                      --&gt;Proxy.getProxy(interfaces)<span class="comment">//目前代理对象interface com.alibaba.dubbo.demo.DemoService, interface com.alibaba.dubbo.rpc.service.EchoService</span></span><br><span class="line">                      --&gt;InvokerInvocationHandler<span class="comment">// 采用jdk自带的InvocationHandler，创建InvokerInvocationHandler对象。      </span></span><br></pre></td></tr></table></figure>
<h3 id="服务引用整体架构设计图"><a href="#服务引用整体架构设计图" class="headerlink" title="服务引用整体架构设计图"></a>服务引用整体架构设计图</h3><img src="/images/dubbo-8.png"><br>消费端调用提供端服务的过程要执行下面几个步骤： </li>
<li>消费端触发请求 </li>
<li>消费端请求编码 </li>
<li>提供端请求解码 </li>
<li>提供端处理请求 </li>
<li>提供端响应结果编码 </li>
<li>消费端响应结果解码<h3 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h3>在进行接口调用时会出现两种情况：<br>1、接口调用成功<br>2、接口调用异常<br>还有一种情况就是接口调用超时。在消费端等待接口返回时，有个timeout参数，这个时间是使用者设置的，可在消费端设置也可以在提供端设置，done.await等待时，会出现两种情况跳出while循环。</li>
<li>线程被唤醒并且已经有了response。</li>
<li>等待时间已经超过timeout，此时也会跳出while，当跳出while循环并且Future中没有response时，就说明接口已超时抛出TimeoutException，框架把TimeoutException<br>封装成RpcException抛给应用层。<br>(1) 超时设置的优先级是什么？<br>客户端方法级 &gt; 服务端方法级 &gt; 客户端接口级 &gt; 服务端接口级 &gt; 客户端全局 &gt; 服务端全局<br>(2) 超时的实现原理是什么？<br>dubbo默认采用了netty做为网络组件，它属于一种NIO的模式。消费端发起远程请求后，线程不会阻塞等待服务端的返回，而是马上得到一个ResponseFuture，消费端通过不断的轮询机制判断结果是否有返回。因为是通过轮询，轮询有个需要特别注要的就是避免死循环，所以为了解决这个问题就引入了超时机制，只在一定时间范围内做轮询，如果超时时间就返回超时异常。<br>(3) 超时解决的是什么问题？<br>对调用的服务设置超时时间，是为了避免因为某种原因导致线程被长时间占用，最终出现线程池用完返回拒绝服务的异常。<br>另外，在Dubbo集群容错部分，给出了服务引用的各功能组件关系图：<br><img src="/images/dubbo-9.png"><h3 id="directory目录"><a href="#directory目录" class="headerlink" title="directory目录"></a>directory目录</h3>通过目录来查找服务，它代表多个invoker，从methodInvokerMap提取，但是他的值是动态，例如注册中心的变更<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Directory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span></span>;</span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Directory有两个实现类，一个静态Directory（不常用）、一个注册中心Directory<br>Directory目录服务</li>
<li>StaticDirectory：静态目录服务，他的Invoker是固定的</li>
<li>RegistryDirectory：注册目录服务，他的Invoker集合数据来源于zk注册中心，他实现了NotifyListener接口，并且实现回调函数 notify(List&lt; URL &gt; urls)，整个过程有一个重要的map变量，methodInvokerMap（它是数据的来源，同时也是notify的重要操作对象；重点是写操作），注册中心有变更就刷新map变量，通过doList（）来读，通过notify(）来写<h3 id="router路由规则"><a href="#router路由规则" class="headerlink" title="router路由规则"></a>router路由规则</h3>在 dubbo 中路由规则决定一次服务调用的目标服务器，分为条件路由规则和脚本路由规则，并且支持可扩展(SPI)。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Router</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Router</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) <span class="keyword">throws</span> RpcException;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
调用 route 方法，传入从目录服务获取到的 Invoke 列表，通过 URL 或者 Invocation 里面配置的条件（路由规则）筛选出满足条件的 Invoke 列表。例如应用隔离或读写分离或灰度发布等等<br>1、什么时候加入ConditionRouter？<br>要修改后台管理或注册中心改变的时候就加入ConditionRouter<br>2、路由规则有哪些实现类？</li>
<li>MockInvokersSelector：默认</li>
<li>ConditionRouter：条件路由，后台管理的路由配置都是条件路由，默认是MockInvokersSelector，只要修改后台管理或注册中心改变的时候就加入ConditionRouter</li>
<li>ScriptRouter：脚本路由<br>下面是 dubbo 路由服务的类图：<br><img src="/images/dubbo-11.png"><br>dubbo 默认会在 AbstractDirectory#setRouters 自动添加 MockInvokersSelector 路由规则。</li>
</ol>
<p><strong>MockInvokersSelector</strong><br>MockInvokersSelector：其实就是用于路由 Mock 服务与非 Mock 服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(<span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers,</span><br><span class="line">                                      URL url, <span class="keyword">final</span> Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="keyword">if</span> (invocation.getAttachments() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getNormalInvokers(invokers);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String value = invocation.getAttachments().get(Constants.INVOCATION_NEED_MOCK);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> getNormalInvokers(invokers);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Boolean.TRUE.toString().equalsIgnoreCase(value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> getMockedInvokers(invokers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码逻辑其实就是：</p>
<ul>
<li>如果 Invocation 的扩展参数不为空 并且 Invocation 的扩展参数里面包含 invocation.need.mock 参数并且值为 true 就获取 Invoke 列表里面 protocol 为 mock 的 Invoke 列表。</li>
<li>否则获取Invoke 列表里面 protocol 为非 mock 的 Invoke 列表。</li>
</ul>
<p><strong>ConditionRouter</strong><br>ConditionRouter：基于条件表达式的路由规则，它的条件规则如下：</p>
<ul>
<li>=&gt; 之前的为消费者匹配条件，所有参数和消费者的 URL 进行对比，当消费者满足匹配条件时，对该消费者执行后面的过滤规则。</li>
<li>=&gt; 之后为提供者地址列表的过滤条件，所有参数和提供者的 URL 进行对比，消费者最终只拿到过滤后的地址列表。</li>
<li>如果匹配条件为空，表示对所有消费方应用，如：=&gt; host != 10.20.153.11</li>
<li>如果过滤条件为空，表示禁止访问，如：host = 10.20.153.10 =&gt;<br>参数支持：</li>
<li>服务调用信息，如：method, argument 等，暂不支持参数路由</li>
<li>URL 本身的字段，如：protocol, host, port 等</li>
<li>以及 URL 上的所有参数，如：application, organization 等<br>条件支持：</li>
<li>等号 = 表示”匹配”，如：host = 10.20.153.10</li>
<li>不等号 != 表示”不匹配”，如：host != 10.20.153.10<br>值支持：</li>
<li>以逗号 , 分隔多个值，如：host != 10.20.153.10,10.20.153.11</li>
<li>以星号 * 结尾，表示通配，如：host != 10.20.*</li>
<li>以美元符 $ 开头，表示引用消费者参数，如：host = $host</li>
</ul>
<p><strong>ScriptRouter</strong><br>ScriptRouter：脚本路由规则，脚本路由规则支持 JDK 脚本引擎的所有脚本，比如：javascript, jruby, groovy 等，通过 type=javascript 参数设置脚本类型，缺省为 javascript。<br>基于脚本引擎的路由规则，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（<span class="function">function <span class="title">route</span><span class="params">(invokers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> java.util.ArrayList(invokers.size());</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; invokers.size(); i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;10.20.153.10&quot;</span>.equals(invokers.get(i).getUrl().getHost())) &#123;</span><br><span class="line">            result.add(invokers.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; (invokers)）; <span class="comment">// 表示立即执行方法</span></span><br></pre></td></tr></table></figure>
<p><strong>Route功能</strong><br>通过配置不同的 Route 规则，我们可以实现以下功能。<br>排除预发布机：<br>     =&gt; host != 172.22.3.91<br>白名单：<br>     host != 10.20.153.10,10.20.153.11 =&gt;<br>黑名单：<br>     host = 10.20.153.10,10.20.153.11 =&gt;<br>服务寄宿在应用上，只暴露一部分的机器，防止整个集群挂掉：<br>     =&gt; host = 172.22.3.1*,172.22.3.2*<br>为重要应用提供额外的机器：<br>     application != kylin =&gt; host != 172.22.3.95,172.22.3.96<br>读写分离：<br>     method = find*,list*,get*,is* =&gt; host = 172.22.3.94,172.22.3.95,172.22.3.96<br>     method != find*,list*,get*,is* =&gt; host = 172.22.3.97,172.22.3.98<br>前后台分离：<br>     application = bops =&gt; host = 172.22.3.91,172.22.3.92,172.22.3.93<br>     application != bops =&gt; host = 172.22.3.94,172.22.3.95,172.22.3.96<br>隔离不同机房网段：<br>     host != 172.22.3.* =&gt; host != 172.22.3.*<br>提供者与消费者部署在同集群内，本机只访问本机的服务：<br>     =&gt; host = $host<br>Router在应用隔离,读写分离,灰度发布中都发挥作用。</p>
<blockquote>
<p>灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。AB test就是一种灰度发布方式，让一部分用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。<br>过程：</p>
</blockquote>
<ol>
<li>首先在192.168.22.58和192.168.22.59两台机器上启动Provider,然后启动Consumer</li>
<li>假设我们要升级192.168.22.58服务器上的服务,接着我们去dubbo的控制台配置路由,切断192.168.22.58的流量,配置完成并且启动之后,就看到此时只调用192.168.22.59的服务</li>
<li>假设此时你在192.168.22.58服务器升级服务,升级完成后再次将启动服务.</li>
<li>由于服务已经升级完成,那么我们此时我们要把刚才的禁用路由取消点,那就是去zookeeper上删除节点，然后刷新控制台的界面</li>
<li>那么此时我们再看控制台的输出,已经恢复正常,整个灰度发布流程结束<h3 id="cluster集群"><a href="#cluster集群" class="headerlink" title="cluster集群"></a>cluster集群</h3>Cluster将Directory中的多个Invoker伪装成一个Invoker来容错，调用失败重试。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(FailoverCluster.NAME)</span><span class="comment">//失败转移，当失败的时候重试其他服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Cluster有八个实现类，也就是有八个集群算法</li>
<li>FailoverCluster：（默认）失败转移，当出现失败，重试其它服务器，通常用于读操作，但重试会带来更长延迟。 </li>
<li>FailfastCluster：快速失败，只发起一次调用，失败立即报错，通常用于非幂等性的写操作。</li>
<li>FailbackCluster：失败自动恢复，后台记录失败请求，定时重发，通常用于消息通知操作。</li>
<li>FailsafeCluster：失败安全，出现异常时，直接忽略，通常用于写入审计日志等操作。</li>
<li>ForkingCluster： 并行调用，只要一个成功即返回，通常用于实时性要求较高的操作，但需要浪费更多服务资源。</li>
<li>BroadcastCluster: 广播调用。遍历所有Invokers, 逐个调用每个调用catch住异常不影响其他invoker调用</li>
<li>MergeableCluster: 分组聚合， 按组合并返回结果，比如菜单服务，接口一样，但有多种实现，用group区分，现在消费方需从每种group中调用一次返回结果，合并结果返回，这样就可以实现聚合菜单项。</li>
<li>AvailableCluster: 获取可用的调用。遍历所有Invokers判断Invoker.isAvalible,只要一个有为true直接调用返回，不管成不成功</li>
</ol>
<p><strong>失败转移源码</strong><br>失败转移和快速失败的区别，是失败转移出现异常会存储异常，而快速失败出现异常会直接抛出去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(FailoverClusterInvoker.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FailoverClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; copyinvokers = invokers;</span><br><span class="line">        checkInvokers(copyinvokers, invocation);</span><br><span class="line">        String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        <span class="comment">//获取重试的次数，默认是3</span></span><br><span class="line">        <span class="keyword">int</span> len = getUrl().getMethodParameter(methodName, Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            len = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// retry loop.</span></span><br><span class="line">        RpcException le = <span class="keyword">null</span>; <span class="comment">// last exception.</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyinvokers.size()); <span class="comment">// invoked invokers.</span></span><br><span class="line">        Set&lt;String&gt; providers = <span class="keyword">new</span> HashSet&lt;String&gt;(len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//重试时，进行重新选择，避免重试时invoker列表已发生变化</span></span><br><span class="line">            <span class="comment">//注意：如果列表发生变化，那么invoker判断会失效，因为invoker示例已经改变</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                checkWhetherDestroyed();</span><br><span class="line">                copyinvokers = list(invocation);</span><br><span class="line">                <span class="comment">// check again</span></span><br><span class="line">                checkInvokers(copyinvokers, invocation);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从负载均衡获取一个invoker</span></span><br><span class="line">            Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyinvokers, invoked);</span><br><span class="line">            invoked.add(invoker);</span><br><span class="line">            RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Result result = invoker.invoke(invocation);</span><br><span class="line">                <span class="keyword">if</span> (le != <span class="keyword">null</span> &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;Although retry the method &quot;</span> + methodName</span><br><span class="line">                            + <span class="string">&quot; in the service &quot;</span> + getInterface().getName()</span><br><span class="line">                            + <span class="string">&quot; was successful by the provider &quot;</span> + invoker.getUrl().getAddress()</span><br><span class="line">                            + <span class="string">&quot;, but there have been failed providers &quot;</span> + providers</span><br><span class="line">                            + <span class="string">&quot; (&quot;</span> + providers.size() + <span class="string">&quot;/&quot;</span> + copyinvokers.size()</span><br><span class="line">                            + <span class="string">&quot;) from the registry &quot;</span> + directory.getUrl().getAddress()</span><br><span class="line">                            + <span class="string">&quot; on the consumer &quot;</span> + NetUtils.getLocalHost()</span><br><span class="line">                            + <span class="string">&quot; using the dubbo version &quot;</span> + Version.getVersion() + <span class="string">&quot;. Last error is: &quot;</span></span><br><span class="line">                            + le.getMessage(), le);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.isBiz()) &#123; <span class="comment">// biz exception.</span></span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                le = e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                le = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                providers.add(invoker.getUrl().getAddress());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(le.getCode(), <span class="string">&quot;Failed to invoke the method &quot;</span></span><br><span class="line">                + methodName + <span class="string">&quot; in the service &quot;</span> + getInterface().getName()</span><br><span class="line">                + <span class="string">&quot;. Tried &quot;</span> + len + <span class="string">&quot; times of the providers &quot;</span> + providers</span><br><span class="line">                + <span class="string">&quot; (&quot;</span> + providers.size() + <span class="string">&quot;/&quot;</span> + copyinvokers.size()</span><br><span class="line">                + <span class="string">&quot;) from the registry &quot;</span> + directory.getUrl().getAddress()</span><br><span class="line">                + <span class="string">&quot; on the consumer &quot;</span> + NetUtils.getLocalHost() + <span class="string">&quot; using the dubbo version &quot;</span></span><br><span class="line">                + Version.getVersion() + <span class="string">&quot;. Last error is: &quot;</span></span><br><span class="line">                + le.getMessage(), le.getCause() != <span class="keyword">null</span> ? le.getCause() : le);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>快速失败源码</strong><br>快速失败，只发起一次调用，失败立即报错，通常用于非幂等性的写操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailfastClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FailfastClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        checkInvokers(invokers, invocation);</span><br><span class="line">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RpcException &amp;&amp; ((RpcException) e).isBiz()) &#123; <span class="comment">// biz exception.</span></span><br><span class="line">                <span class="keyword">throw</span> (RpcException) e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//失败转移和快速失败的区别，是失败转移出现异常会存储异常，而快速失败出现异常会直接抛出去</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e <span class="keyword">instanceof</span> RpcException ? ((RpcException) e).getCode() : <span class="number">0</span>,</span><br><span class="line">                    <span class="string">&quot;Failfast invoke providers &quot;</span> + invoker.getUrl() + <span class="string">&quot; &quot;</span> + loadbalance.getClass().getSimpleName()</span><br><span class="line">                            + <span class="string">&quot; select from all providers &quot;</span> + invokers + <span class="string">&quot; for service &quot;</span> + getInterface().getName()</span><br><span class="line">                            + <span class="string">&quot; method &quot;</span> + invocation.getMethodName() + <span class="string">&quot; on consumer &quot;</span> + NetUtils.getLocalHost()</span><br><span class="line">                            + <span class="string">&quot; use dubbo version &quot;</span> + Version.getVersion()</span><br><span class="line">                            + <span class="string">&quot;, but no luck to perform the invocation. Last error is: &quot;</span> + e.getMessage(),</span><br><span class="line">                    e.getCause() != <span class="keyword">null</span> ? e.getCause() : e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="loadbalance负载均衡"><a href="#loadbalance负载均衡" class="headerlink" title="loadbalance负载均衡"></a>loadbalance负载均衡</h3><p>loadbalance负载均衡：从多个Invoker选取一个做本次调用，具体包含很多负载均衡算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@SPI(RandomLoadBalance.NAME)&#x2F;&#x2F;默认是随机</span><br><span class="line">public interface LoadBalance &#123;</span><br><span class="line">    @Adaptive(&quot;loadbalance&quot;)&#x2F;&#x2F;动态编译</span><br><span class="line">    &lt;T&gt; Invoker&lt;T&gt; select(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loadbalance负载均衡有四个实现类</p>
<ol>
<li>RandomLoadBalance：随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。 </li>
<li>RoundRobin LoadBalance：轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>
<li>LeastActiveLoadBalance：最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li>
<li>ConsistentHash LoadBalance：一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。<h3 id="dubbo实现SOA的服务降级"><a href="#dubbo实现SOA的服务降级" class="headerlink" title="dubbo实现SOA的服务降级"></a>dubbo实现SOA的服务降级</h3>什么是服务开关？</li>
</ol>
<ul>
<li>先讲一下开关的由来，例如淘宝在11月11日做促销活动，在交易下单环节，可能需要调用A、B、C三个接口来完成，但是其实A和B是必须的，  C只是附加的功能（例如在下单的时候做一下推荐，或push消息），可有可无，在平时系统没有压力，容量充足的情况下，调用下没问题，但是在类似店庆之类的大促环节， 系统已经满负荷了，这时候其实完全可以不去调用C接口，怎么实现这个呢？  改代码？<br>什么是服务降级</li>
<li>服务降级，当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。<br>dubbo如何实现服务降级？<br>1、容错：当系统出现非业务异常(比如并发数太高导致超时，网络异常等)时，不对该接口进行处理。（不可知）<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mock=fail:return null</span><br></pre></td></tr></table></figure>
2、 屏蔽：在大促，促销活动的可预知情况下，例如双11活动。采用直接屏蔽接口访问。（可知）<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mock=force:return null</span><br></pre></td></tr></table></figure>
<h3 id="Dubbo的限流与降级怎么实现的？"><a href="#Dubbo的限流与降级怎么实现的？" class="headerlink" title="Dubbo的限流与降级怎么实现的？"></a>Dubbo的限流与降级怎么实现的？</h3></li>
</ul>
<ol>
<li>dubbo的服务者与消费者 service的配置，最大连接数 与 请求数目配置</li>
<li>dubbo的超时设置 + 配置mock 类。 请求超时后会执行mock，并返回</li>
<li>dubbo可以通过扩展Filter的方式引入Hystrix，具体代码如下：<a target="_blank" rel="noopener" href="https://github.com/yskgood/dubbo-hystrix-support">https://github.com/yskgood/dubbo-hystrix-support</a><h2 id="9、Dubbo把网络通信的IO异步变同步"><a href="#9、Dubbo把网络通信的IO异步变同步" class="headerlink" title="9、Dubbo把网络通信的IO异步变同步"></a>9、Dubbo把网络通信的IO异步变同步</h2>先讲一下单工、全双工 、半双工 区别</li>
<li>单工：在同一时间只允许一方向另一方传送信息，而另一方不能向一方传送 </li>
<li>全双工：是指在发送数据的同时也能够接收数据，两者同步进行，这好像我们平时打电话一样，说话的同时也能够听到对方的声音。目前的网卡一般都支持全双工。 </li>
<li>半双工：所谓半双工就是指一个时间段内只有一个动作发生，举个简单例子，一条窄窄的马路，同时只能有一辆车通过，当目前有两量车对开，这种情况下就只能一辆先过，等到头后另一辆再开，这个例子就形象的说明了半双工的原理。<br>dubbo 是基于netty NIO的非阻塞 并行调用通信。 （阻塞  非阻塞  异步  同步 区别 ）<br>dubbo从头到脚都是异步的<br>dubbo 的通信方式 有3类类型：<h3 id="1-异步，无返回值"><a href="#1-异步，无返回值" class="headerlink" title="1. 异步，无返回值"></a>1. 异步，无返回值</h3>这种请求最简单，consumer 把请求信息发送给 provider 就行了。只是需要在 consumer 端把请求方式配置成异步请求就好了。如下：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">return</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:method</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-异步，有返回值"><a href="#2-异步，有返回值" class="headerlink" title="2. 异步，有返回值"></a>2. 异步，有返回值</h3>这种情况下consumer首先把请求信息发送给provider，这个时候在consumer端不仅把请求方式配置成异步，并且需要RpcContext这个ThreadLocal对象获取到Future对象，然后通过Future#get( )阻塞式获取provider的相应，那么这个Future是如何添加到RpcContext中呢？<br>在第二小节讲服务发送的时候， 在 DubboInvoke 里面有三种调用方式，之前只具体请求了同步请求的发送方式而且没有异步请求的发送。异步请求发送代码如下：<blockquote>
<p>DubboInvoker#doInvoke 中的 else if (isAsync) 分支</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ResponseFuture future = currentClient.request(inv, timeout);</span><br><span class="line">FutureAdapter&lt;T&gt; futureAdapter = <span class="keyword">new</span> FutureAdapter&lt;&gt;(future);</span><br><span class="line">RpcContext.getContext().setFuture(futureAdapter);</span><br><span class="line">Result result;</span><br><span class="line"><span class="keyword">if</span> (RpcUtils.isAsyncFuture(getUrl(), inv)) &#123;</span><br><span class="line">    result = <span class="keyword">new</span> AsyncRpcResult&lt;&gt;(futureAdapter);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = <span class="keyword">new</span> RpcResult();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
上面的代码逻辑是直接发送请求到 provider 返回一个 ResponseFuture 实例，然后把这个 Future 对象保存到 RpcContext#LOCAL 这个 ThreadLocal 当前线程对象当中，并且返回一个空的 RpcResult对象。如果要获取到 provider响应的信息，需要进行以下操作：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到调用的Future引用，当结果返回后，会被通知和设置到此Future</span></span><br><span class="line">Future&lt;String&gt; temp= RpcContext.getContext().getFuture();</span><br><span class="line"><span class="comment">// 同理等待bar返回</span></span><br><span class="line">hello=temp.get();</span><br></pre></td></tr></table></figure>
配置为异步，有返回值<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">async</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:method</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-异步，变同步（默认的通信方式）"><a href="#3-异步，变同步（默认的通信方式）" class="headerlink" title="3. 异步，变同步（默认的通信方式）"></a>3. 异步，变同步（默认的通信方式）</h3>异步变同步其实原理和异步请求的通过 Future#get 等待 provider 响应返回一样，只不过异步有返回值是显示调用而默认是 dubbo 内部把这步完成了。<br>A. 当前线程怎么让它 “暂停，等结果回来后，再执行”？<br>B. socket是一个全双工的通信方式，那么在多线程的情况下，如何知道那个返回结果对应原先那条线程的调用？<br>​<br>通过一个全局唯一的ID来做consumer 和 provider 来回传输。<br>我们都知道在 consumer 发送请求的时候会调用 HeaderExchangeChannel#request 方法：<blockquote>
<p>HeaderExchangeChannel#request</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>.getLocalAddress(), <span class="keyword">null</span>, <span class="string">&quot;Failed to send request &quot;</span> + request + <span class="string">&quot;, cause: The channel &quot;</span> + <span class="keyword">this</span> + <span class="string">&quot; is closed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// create request.</span></span><br><span class="line">    Request req = <span class="keyword">new</span> Request();</span><br><span class="line">    req.setVersion(Version.getProtocolVersion());</span><br><span class="line">    req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">    req.setData(request);</span><br><span class="line">    DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, req, timeout);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.send(req);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">        future.cancel();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
它首先会通过 dubbo 自定义的 Channel、Request 与 timeout(int) 构造一个 DefaultFuture 对象。然后再通过 NettyChannel 发送请求到 provider，最后返回这个 DefaultFuture。下面我们来看一下通过构造方法是如何创建 DefaultFuture 的。我只把主要涉及到的属性展示出来：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFuture</span> <span class="keyword">implements</span> <span class="title">ResponseFuture</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, Channel&gt; CHANNELS = <span class="keyword">new</span> ConcurrentHashMap&lt;Long, Channel&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, DefaultFuture&gt; FUTURES = <span class="keyword">new</span> ConcurrentHashMap&lt;Long, DefaultFuture&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Request request;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> timeout;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">        <span class="keyword">this</span>.id = request.getId();</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout &gt; <span class="number">0</span> ? timeout : channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">        <span class="comment">// put into waiting map.</span></span><br><span class="line">        FUTURES.put(id, <span class="keyword">this</span>);</span><br><span class="line">        CHANNELS.put(id, channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个 id 是在创建 Request 的时候使用 AtomicLong#getAndIncrement 生成的。从 1 开始并且如果它一直增加直到生成负数也能保证这台机器这个值是唯一的，且不冲突的。符合唯一主键原则。 dubbo 默认同步变异步其实和异步调用一样，也是在 DubboInvoker#doInvoke 实现的。<blockquote>
<p>DubboInvoker#doInvoke</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">return</span> (Result) currentClient.request(inv, timeout).get();</span><br></pre></td></tr></table></figure>
关键就在 ResponseFuture#get 方法上面，下面我们来看一下这个方法的源码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        timeout = Constants.DEFAULT_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!isDone()) &#123;</span><br><span class="line">                done.await(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">if</span> (isDone() || System.currentTimeMillis() - start &gt; timeout) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(sent &gt; <span class="number">0</span>, channel, getTimeoutMessage(<span class="keyword">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnFromResponse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其实就是 while 循环，利用 java 的 lock 机制判断如果在超时时间范围内 DefaultFuture#response 如果赋值成不为空就返回响应，否则抛出 TimeoutException 异常。<br>还记得 consumer 接收 provider 响应的最后一步吗？就是 DefaultFuture#received，在 provider 端会带回 consumer请求的 id。我们来看一下它的具体处理逻辑：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Response response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DefaultFuture future = FUTURES.remove(response.getId());</span><br><span class="line">        <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">            future.doReceived(response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;The timeout response finally returned at &quot;</span></span><br><span class="line">                    + (<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>).format(<span class="keyword">new</span> Date()))</span><br><span class="line">                    + <span class="string">&quot;, response &quot;</span> + response</span><br><span class="line">                    + (channel == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;, channel: &quot;</span> + channel.getLocalAddress()</span><br><span class="line">                    + <span class="string">&quot; -&gt; &quot;</span> + channel.getRemoteAddress()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        CHANNELS.remove(response.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
它会从最开始通过构造函数传进去的 DefaultFuture#FUTURES 根据请求的 id 拿到 DefaultFuture ，然后根据这个 DefaultFuture 调用 DefaultFuture#doReceived 方法。通过 Java 里面的 lock 机制把 provider 的值赋值给 DefaultFuture#response。此时 consumer 也正在调用 DefaultFuture#get 方法进行阻塞，当这个 DefaultFuture#response 被赋值后，它的值就不为空。阻塞操作完成，且根据请求号的 id 把 consumer 端的 Request以及 Provider 端返回的 Response 关联了起来。<h2 id="10、Dubbo网络通信的编解码"><a href="#10、Dubbo网络通信的编解码" class="headerlink" title="10、Dubbo网络通信的编解码"></a>10、Dubbo网络通信的编解码</h2><h3 id="什么是编码、解码？"><a href="#什么是编码、解码？" class="headerlink" title="什么是编码、解码？"></a>什么是编码、解码？</h3></li>
<li>编码（Encode）称为序列化（serialization），它将对象序列化为字节数组，用于网络传输、数据持久化或者其它用途。</li>
<li>解码（Decode）反序列化（deserialization）把从网络、磁盘等读取的字节数组还原成原始对象（通常是原始对象的拷贝），以方便后续的业务逻辑操作。<br><img src="/images/dubbo-12.png"><h3 id="tcp-为什么会出现粘包拆包的问题？"><a href="#tcp-为什么会出现粘包拆包的问题？" class="headerlink" title="tcp 为什么会出现粘包拆包的问题？"></a>tcp 为什么会出现粘包拆包的问题？</h3>TCP是个“流”协议，所谓流，就是没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包的问题。<h3 id="tcp-怎么解决粘包-拆包的问题？"><a href="#tcp-怎么解决粘包-拆包的问题？" class="headerlink" title="tcp 怎么解决粘包 拆包的问题？"></a>tcp 怎么解决粘包 拆包的问题？</h3></li>
<li>封装自己的包协议：包=包内容长度(4byte)+包内容，这样数据包之间的边界就清楚了。</li>
<li>就是在包尾增加回车或空格等特殊字符作为切割，典型的FTP协议</li>
<li>将消息分为消息头消息体。例如 dubbo<br>在我们眼中的http、tcp协议的包体应该都历历在目。大约是header + body，当然这个dubbo也不失众人所望，仍是如此结构<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3>下面我们来看一下 dubbo 的协议头约定：<br><img src="/images/dubbo-13.png"><br>dubbo 使用长度为 16 的 byte 数组作为协议头。1 个 byte 对应 8 位。所以 dubbo 的协议头有 128 位 (也就是上图的从 0 到 127)。我们来看一下这 128 位协议头分别代表什么意思。</li>
</ol>
<ul>
<li>0 ~ 7 ： dubbo 魔数((short) 0xdabb) 高位，也就是 (short) 0xda。</li>
<li>8 ~ 15： dubbo 魔数((short) 0xdabb) 低位，也就是 (short) 0xbb。</li>
<li>16 ~ 20：序列化 id(Serialization id)，也就是 dubbo 支持的序列化中的 contentTypeId，比如 Hessian2Serialization#ID 为 2</li>
<li>21 ：是否事件(event )</li>
<li>22 ： 是否 Two way 模式(Two way)。默认是 Two-way 模式，<a href="dubbo:method">dubbo:method</a> 标签的 return 属性配置为false，则是oneway模式</li>
<li>23 ：标记是请求对象还是响应对象(Req/res)</li>
<li>24 ~ 31：response 的结果响应码 ，例如 OK=20</li>
<li>32 ~ 95：id(long)，异步变同步的全局唯一ID，用来做consumer和provider的来回通信标记。</li>
<li>96 ~ 127： data length，请求或响应数据体的数据长度也就是消息头+请求数据的长度。用于处理 dubbo 通信的粘包与拆包问题。<h3 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h3>128 位 之后表示消息体内容，在使用hession序列化的时候，直接使用的是writeUTF方法。</li>
<li>Dubbo version</li>
<li>Service name</li>
<li>Service version</li>
<li>Method name</li>
<li>Method parameter types</li>
<li>Method arguments</li>
<li>Attachments<br>hession2编码相关代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RpcInvocation inv = (RpcInvocation) data;</span><br><span class="line">out.writeUTF(inv.getAttachment(Constants.DUBBO_VERSION_KEY, DUBBO_VERSION));</span><br><span class="line">out.writeUTF(inv.getAttachment(Constants.PATH_KEY));</span><br><span class="line">out.writeUTF(inv.getAttachment(Constants.VERSION_KEY));</span><br><span class="line">out.writeUTF(inv.getMethodName());</span><br><span class="line">out.writeUTF(ReflectUtils.getDesc(inv.getParameterTypes()));</span><br><span class="line">Object[] args = inv.getArguments();</span><br><span class="line"><span class="keyword">if</span> (args != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        out.writeObject(encodeInvocationArgument(channel, inv, i));</span><br><span class="line">    &#125;</span><br><span class="line">out.writeObject(inv.getAttachments());</span><br></pre></td></tr></table></figure>
hession2解码相关代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)</span><br><span class="line">                .deserialize(channel.getUrl(), input);</span><br><span class="line">        <span class="comment">// 1. 读取dubbo-version</span></span><br><span class="line">        setAttachment(Constants.DUBBO_VERSION_KEY, in.readUTF());</span><br><span class="line">        <span class="comment">// 2. 读取服务path</span></span><br><span class="line">        setAttachment(Constants.PATH_KEY, in.readUTF());</span><br><span class="line">        <span class="comment">// 3. 读取服务version</span></span><br><span class="line">        setAttachment(Constants.VERSION_KEY, in.readUTF());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 读取远程方法名</span></span><br><span class="line">        setMethodName(in.readUTF());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] args;</span><br><span class="line">            Class&lt;?&gt;[] pts;</span><br><span class="line">            <span class="comment">// 读取方法参数描述</span></span><br><span class="line">            <span class="comment">// @see ReflectUtils.getDesc(Class&lt;?&gt; clazz)</span></span><br><span class="line">            String desc = in.readUTF();</span><br><span class="line">            <span class="keyword">if</span> (desc.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                pts = DubboCodec.EMPTY_CLASS_ARRAY;</span><br><span class="line">                args = DubboCodec.EMPTY_OBJECT_ARRAY;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 解析</span></span><br><span class="line">                pts = ReflectUtils.desc2classArray(desc);</span><br><span class="line">                args = <span class="keyword">new</span> Object[pts.length];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 遍历读取参数</span></span><br><span class="line">                        args[i] = in.readObject(pts[i]);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                            log.warn(<span class="string">&quot;Decode argument failed: &quot;</span> + e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置方法参数类型</span></span><br><span class="line">            setParameterTypes(pts);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 读取attachments</span></span><br><span class="line">            Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) in.readObject(Map.class);</span><br><span class="line">            <span class="keyword">if</span> (map != <span class="keyword">null</span> &amp;&amp; map.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Map&lt;String, String&gt; attachment = getAttachments();</span><br><span class="line">                <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    attachment = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                attachment.putAll(map);</span><br><span class="line">                setAttachments(attachment);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否是callback</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                args[i] = decodeInvocationArgument(channel, <span class="keyword">this</span>, pts, i, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 设置args </span></span><br><span class="line">            setArguments(args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">&quot;Read invocation data failed.&quot;</span>, e));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">                ((Cleanable) in).cleanup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-consumer请求编码"><a href="#1-consumer请求编码" class="headerlink" title="1. consumer请求编码"></a>1. consumer请求编码</h3>consumer 在请求 provider 的时候需要把 Request 对象转化成 byte 数组，所以它是一个需要编码的过程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------<span class="number">1</span>------consumer请求编码----------------------</span><br><span class="line">--&gt;NettyCodecAdapter.InternalEncoder.encode</span><br><span class="line">  --&gt;DubboCountCodec.encode</span><br><span class="line">    --&gt;ExchangeCodec.encode</span><br><span class="line">      --&gt;ExchangeCodec.encodeRequest</span><br><span class="line">        --&gt;DubboCodec.encodeRequestData</span><br></pre></td></tr></table></figure>
<h4 id="消息头编码"><a href="#消息头编码" class="headerlink" title="消息头编码"></a>消息头编码</h4>com.alibaba.dubbo.remoting.exchange.codec.ExchangeCodec.encode(Channel, ChannelBuffer, Object) <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(Channel channel, ChannelBuffer buffer, Object msg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">          encodeRequest(channel, buffer, (Request) msg);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">          encodeResponse(channel, buffer, (Response) msg);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">super</span>.encode(channel, buffer, msg);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
首先判断这一次是请求还是响应。<br>com.alibaba.dubbo.remoting.exchange.codec.ExchangeCodec.encodeRequest(Channel, ChannelBuffer, Object) <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeRequest</span><span class="params">(Channel channel, ChannelBuffer buffer, Request req)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       Serialization serialization = getSerialization(channel);</span><br><span class="line">       <span class="comment">// header.</span></span><br><span class="line">       <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[HEADER_LENGTH];</span><br><span class="line">       <span class="comment">// 2字节 魔数</span></span><br><span class="line">       Bytes.short2bytes(MAGIC, header);</span><br><span class="line">       <span class="comment">// 1字节 序列类</span></span><br><span class="line">       header[<span class="number">2</span>] = (<span class="keyword">byte</span>) (FLAG_REQUEST | serialization.getContentTypeId());</span><br><span class="line">       <span class="keyword">if</span> (req.isTwoWay()) &#123;</span><br><span class="line">           header[<span class="number">2</span>] |= FLAG_TWOWAY;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (req.isEvent()) &#123;</span><br><span class="line">           header[<span class="number">2</span>] |= FLAG_EVENT;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//  8字节 请求id</span></span><br><span class="line">       Bytes.long2bytes(req.getId(), header, <span class="number">4</span>);</span><br><span class="line">       <span class="comment">// encode request data.</span></span><br><span class="line">       <span class="keyword">int</span> savedWriteIndex = buffer.writerIndex();</span><br><span class="line">       buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);</span><br><span class="line">       ChannelBufferOutputStream bos = <span class="keyword">new</span> ChannelBufferOutputStream(buffer);</span><br><span class="line">       ObjectOutput out = serialization.serialize(channel.getUrl(), bos);</span><br><span class="line">       <span class="keyword">if</span> (req.isEvent()) &#123;</span><br><span class="line">           encodeEventData(channel, out, req.getData());</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           encodeRequestData(channel, out, req.getData(), req.getVersion());</span><br><span class="line">       &#125;</span><br><span class="line">       out.flushBuffer();</span><br><span class="line">       <span class="keyword">if</span> (out <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">           ((Cleanable) out).cleanup();</span><br><span class="line">       &#125;</span><br><span class="line">       bos.flush();</span><br><span class="line">       bos.close();</span><br><span class="line">       <span class="keyword">int</span> len = bos.writtenBytes();</span><br><span class="line">       checkPayload(channel, len);</span><br><span class="line">       <span class="comment">// 4字节 请求数据长度</span></span><br><span class="line">       Bytes.int2bytes(len, header, <span class="number">12</span>);</span><br><span class="line">       <span class="comment">// write</span></span><br><span class="line">       buffer.writerIndex(savedWriteIndex);</span><br><span class="line">       buffer.writeBytes(header); <span class="comment">// write header.</span></span><br><span class="line">       buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-provider-请求解码"><a href="#2-provider-请求解码" class="headerlink" title="2. provider 请求解码"></a>2. provider 请求解码</h3>provider 在接收 consumer 请求的时候需要把 byte 数组转化成 Request 对象，所以它是一个需要解码的过程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----------<span class="number">2</span>------provider 请求解码----------------------</span><br><span class="line">--NettyCodecAdapter.InternalDecoder.messageReceived</span><br><span class="line">  --&gt;DubboCountCodec.decode</span><br><span class="line">    --&gt;ExchangeCodec.decode</span><br><span class="line">      --&gt;ExchangeCodec.decodeBody</span><br></pre></td></tr></table></figure>
<h4 id="解析消息头"><a href="#解析消息头" class="headerlink" title="解析消息头"></a>解析消息头</h4>com.alibaba.dubbo.remoting.exchange.codec.ExchangeCodec.encode(Channel, ChannelBuffer, int, byte[]) <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer, <span class="keyword">int</span> readable, <span class="keyword">byte</span>[] header)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// check magic number.</span></span><br><span class="line">      <span class="keyword">if</span> (readable &gt; <span class="number">0</span> &amp;&amp; header[<span class="number">0</span>] != MAGIC_HIGH</span><br><span class="line">              || readable &gt; <span class="number">1</span> &amp;&amp; header[<span class="number">1</span>] != MAGIC_LOW) &#123;</span><br><span class="line">          <span class="keyword">int</span> length = header.length;</span><br><span class="line">          <span class="keyword">if</span> (header.length &lt; readable) &#123;</span><br><span class="line">              header = Bytes.copyOf(header, readable);</span><br><span class="line">              buffer.readBytes(header, length, readable - length);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; header.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (header[i] == MAGIC_HIGH &amp;&amp; header[i + <span class="number">1</span>] == MAGIC_LOW) &#123;</span><br><span class="line">                  buffer.readerIndex(buffer.readerIndex() - header.length + i);</span><br><span class="line">                  header = Bytes.copyOf(header, i);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">super</span>.decode(channel, buffer, readable, header);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// check length.</span></span><br><span class="line">      <span class="keyword">if</span> (readable &lt; HEADER_LENGTH) &#123;</span><br><span class="line">          <span class="keyword">return</span> DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// get data length.</span></span><br><span class="line">      <span class="keyword">int</span> len = Bytes.bytes2int(header, <span class="number">12</span>);</span><br><span class="line">      checkPayload(channel, len);</span><br><span class="line">      <span class="keyword">int</span> tt = len + HEADER_LENGTH;</span><br><span class="line">      <span class="keyword">if</span> (readable &lt; tt) &#123;</span><br><span class="line">          <span class="keyword">return</span> DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// limit input stream.</span></span><br><span class="line">      ChannelBufferInputStream is = <span class="keyword">new</span> ChannelBufferInputStream(buffer, len);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> decodeBody(channel, is, header);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (is.available() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                      logger.warn(<span class="string">&quot;Skip input stream &quot;</span> + is.available());</span><br><span class="line">                  &#125;</span><br><span class="line">                  StreamUtils.skipUnusedStream(is);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                  logger.warn(e.getMessage(), e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
这个方法主要是检查请求头的相关信息</li>
</ul>
<ol>
<li>检查魔法数，魔法数高位和低位各占1字节</li>
<li>检查当前请求头是否完整，如果不完整直接返回</li>
<li>获取此次请求体的长度。然后判断 请求头+消息体长度 是否 大于此次消息包的长度，如果大于的话，说明此次的消息不是完整的一个消息，也意味着进行拆包了，直接返回，等待其它信息<h4 id="解析消息体"><a href="#解析消息体" class="headerlink" title="解析消息体"></a>解析消息体</h4>com.alibaba.dubbo.remoting.exchange.codec.ExchangeCodec.decodeBody(Channel , InputStream , byte[])<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decodeBody</span><span class="params">(Channel channel, InputStream is, <span class="keyword">byte</span>[] header)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> flag = header[<span class="number">2</span>], proto = (<span class="keyword">byte</span>) (flag &amp; SERIALIZATION_MASK);</span><br><span class="line">        <span class="comment">// get request id.</span></span><br><span class="line">        <span class="keyword">long</span> id = Bytes.bytes2long(header, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; FLAG_REQUEST) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// decode response.</span></span><br><span class="line">            Response res = <span class="keyword">new</span> Response(id);</span><br><span class="line">            <span class="keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="number">0</span>) &#123;</span><br><span class="line">                res.setEvent(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// get status.</span></span><br><span class="line">            <span class="keyword">byte</span> status = header[<span class="number">3</span>];</span><br><span class="line">            res.setStatus(status);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);</span><br><span class="line">                <span class="keyword">if</span> (status == Response.OK) &#123;</span><br><span class="line">                    Object data;</span><br><span class="line">                    <span class="keyword">if</span> (res.isHeartbeat()) &#123;</span><br><span class="line">                        data = decodeHeartbeatData(channel, in);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.isEvent()) &#123;</span><br><span class="line">                        data = decodeEventData(channel, in);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        data = decodeResponseData(channel, in, getRequestData(id));</span><br><span class="line">                    &#125;</span><br><span class="line">                    res.setResult(data);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.setErrorMessage(in.readUTF());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                res.setStatus(Response.CLIENT_ERROR);</span><br><span class="line">                res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// decode request.</span></span><br><span class="line">            Request req = <span class="keyword">new</span> Request(id);</span><br><span class="line">            req.setVersion(Version.getProtocolVersion());</span><br><span class="line">            req.setTwoWay((flag &amp; FLAG_TWOWAY) != <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="number">0</span>) &#123;</span><br><span class="line">                req.setEvent(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);</span><br><span class="line">                Object data;</span><br><span class="line">                <span class="keyword">if</span> (req.isHeartbeat()) &#123;</span><br><span class="line">                    data = decodeHeartbeatData(channel, in);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.isEvent()) &#123;</span><br><span class="line">                    data = decodeEventData(channel, in);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    data = decodeRequestData(channel, in);</span><br><span class="line">                &#125;</span><br><span class="line">                req.setData(data);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="comment">// bad request</span></span><br><span class="line">                req.setBroken(<span class="keyword">true</span>);</span><br><span class="line">                req.setData(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> req;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
这一步骤是解析request和response。以response为例</li>
<li>首先判断这一次是请求还是响应</li>
<li>根据消息解析出来的此次响应/请求的status，判断此次的消息是否正常</li>
<li>解析此次的消息使用的序列化方式，然后进行反序列化，这里会反序列化为一个Object，可以参照Hessian2ObjectInput</li>
<li>解析成功，返回response到上游方法<h3 id="3-provider响应结果编码"><a href="#3-provider响应结果编码" class="headerlink" title="3. provider响应结果编码"></a>3. provider响应结果编码</h3>provider 在处理完成 consumer 请求需要响应结果的时候需要把 Response 对象转化成 byte 数组，所以它是一个需要编码的过程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------<span class="number">3</span>------provider响应结果编码----------------------</span><br><span class="line">--&gt;NettyCodecAdapter.InternalEncoder.encode</span><br><span class="line">  --&gt;DubboCountCodec.encode</span><br><span class="line">    --&gt;ExchangeCodec.encode</span><br><span class="line">      --&gt;ExchangeCodec.encodeResponse</span><br><span class="line">        --&gt;DubboCodec.encodeResponseData<span class="comment">//先写入一个字节 这个字节可能是RESPONSE_NULL_VALUE  RESPONSE_VALUE  RESPONSE_WITH_EXCEPTION</span></span><br></pre></td></tr></table></figure>
<h3 id="4-consumer响应结果解码"><a href="#4-consumer响应结果解码" class="headerlink" title="4. consumer响应结果解码"></a>4. consumer响应结果解码</h3>consumer 在接收 provider 响应的时候需要把 byte 数组转化成 Response 对象，所以它是一个需要解码的过程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------<span class="number">4</span>------consumer响应结果解码----------------------</span><br><span class="line">--NettyCodecAdapter.InternalDecoder.messageReceived</span><br><span class="line">  --&gt;DubboCountCodec.decode</span><br><span class="line">    --&gt;ExchangeCodec.decode</span><br><span class="line">      --&gt;DubboCodec.decodeBody</span><br><span class="line">        --&gt;DecodeableRpcResult.decode<span class="comment">//根据RESPONSE_NULL_VALUE  RESPONSE_VALUE  RESPONSE_WITH_EXCEPTION进行响应的处理</span></span><br></pre></td></tr></table></figure>
<h2 id="11、Dubbo注册机制"><a href="#11、Dubbo注册机制" class="headerlink" title="11、Dubbo注册机制"></a>11、Dubbo注册机制</h2>Dubbo服务发布影响流程的主要包括三个部分，依次是：</li>
<li>服务暴露</li>
<li>心跳</li>
<li>服务注册<br>服务暴露是对外提供服务及暴露端口，以便消费端可以正常调通服务。心跳机制保证服务器端及客户端正常长连接的保持，服务注册是向注册中心注册服务暴露服务的过程。<h3 id="1-RegistryProtocol-export-Invoker"><a href="#1-RegistryProtocol-export-Invoker" class="headerlink" title="1. RegistryProtocol.export(Invoker)"></a>1. RegistryProtocol.export(Invoker<T>)</h3>RegistryProtocol 调用了DubboProtocol及注册服务，其中DubboProtocol 实现了服务暴露及心跳检测功能。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">// 暴露服务</span></span><br><span class="line">    <span class="comment">//export invoker</span></span><br><span class="line">    <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class="line">    <span class="comment">//registry provider 添加定时任务  ping request response</span></span><br><span class="line">    <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">    <span class="comment">// 获得服务提供者 URL</span></span><br><span class="line">    <span class="keyword">final</span> URL registedProviderUrl = getRegistedProviderUrl(originInvoker);</span><br><span class="line">    registry.register(registedProviderUrl);</span><br><span class="line">    <span class="comment">// 订阅override数据</span></span><br><span class="line">    <span class="comment">// FIXME 提供者订阅时，会影响同一JVM即暴露服务，又引用同一服务的的场景，因为subscribed以服务名为缓存的key，导致订阅信息覆盖。</span></span><br><span class="line">    <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);</span><br><span class="line">    <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    <span class="comment">// 省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>ExporterChangeableWrapper<T> doLocalExport(final Invoker<T> originInvoker) 为暴露服务的执行过程。</li>
<li>根据originInvoker中注册中心信息获取对应的Registry对象,因为这里是zookeeper协议，所以为ZookeeperRegistry对象</li>
<li>从注册中心的URL中获得 export 参数对应的值，即服务提供者的URL.</li>
<li>registry.register(registedProviderUrl); 用之前创建的注册中心对象注册服务<h3 id="2-AbstractRegistryFactory-getRegistry-URL"><a href="#2-AbstractRegistryFactory-getRegistry-URL" class="headerlink" title="2. AbstractRegistryFactory.getRegistry(URL)"></a>2. AbstractRegistryFactory.getRegistry(URL)</h3>上面提到 Registry getRegistry(final Invoker&lt;?&gt; originInvoker) 是根据invoker的地址获取registry实例代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Registry <span class="title">getRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    url = url.setPath(RegistryService.class.getName())</span><br><span class="line">            .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())</span><br><span class="line">            .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY);</span><br><span class="line">    String key = url.toServiceString();   <span class="comment">// zookeeper://192.168.1.157:2181/com.alibaba.dubbo.registry.RegistryService</span></span><br><span class="line">    <span class="comment">// 锁定注册中心获取过程，保证注册中心单一实例</span></span><br><span class="line">    LOCK.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Registry registry = REGISTRIES.get(key);</span><br><span class="line">        <span class="keyword">if</span> (registry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> registry;</span><br><span class="line">        &#125;</span><br><span class="line">        registry = createRegistry(url);</span><br><span class="line">        <span class="keyword">if</span> (registry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Can not create registry &quot;</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        REGISTRIES.put(key, registry);</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        LOCK.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>设置Path属性，添加interface参数信息，及移除export 和 refer 参数信息。执行结果如下：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.registry.RegistryService&amp;owner=uce&amp;pid=12028&amp;timestamp=1531912729343</span><br></pre></td></tr></table></figure></li>
<li>获取url对应的serviceString信息：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService</span><br></pre></td></tr></table></figure></li>
<li>顺序地创建注册中心：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Registry ZookeeperRegistryFactory.createRegistry(URL url);</span><br></pre></td></tr></table></figure>
<h3 id="3-ZookeeperRegistry、FailbackRegistry、AbstractRegistry"><a href="#3-ZookeeperRegistry、FailbackRegistry、AbstractRegistry" class="headerlink" title="3. ZookeeperRegistry、FailbackRegistry、AbstractRegistry"></a>3. ZookeeperRegistry、FailbackRegistry、AbstractRegistry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ZookeeperRegistry(url, zookeeperTransporter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造ZookeeperRegistry的调用链如下所示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span><span class="params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(url);</span><br><span class="line">    <span class="keyword">if</span> (url.isAnyHost()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;registry address == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">    <span class="keyword">if</span> (!group.startsWith(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">        group = Constants.PATH_SEPARATOR + group;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.root = group;</span><br><span class="line">    zkClient = zookeeperTransporter.connect(url);</span><br><span class="line">    zkClient.addStateListener(<span class="keyword">new</span> StateListener() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (state == RECONNECTED) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    recover();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FailbackRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(url);</span><br><span class="line">    <span class="keyword">int</span> retryPeriod = url.getParameter(Constants.REGISTRY_RETRY_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RETRY_PERIOD);</span><br><span class="line">    <span class="keyword">this</span>.retryFuture = retryExecutor.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 检测并连接注册中心</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                retry();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// 防御性容错</span></span><br><span class="line">                logger.error(<span class="string">&quot;Unexpected error occur at failed retry, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, retryPeriod, retryPeriod, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    setUrl(url);</span><br><span class="line">    <span class="comment">// 启动文件保存定时器</span></span><br><span class="line">    syncSaveFile = url.getParameter(Constants.REGISTRY_FILESAVE_SYNC_KEY, <span class="keyword">false</span>);</span><br><span class="line">    String filename = url.getParameter(Constants.FILE_KEY, System.getProperty(<span class="string">&quot;user.home&quot;</span>) + <span class="string">&quot;/.dubbo/dubbo-registry-&quot;</span> + url.getHost() + <span class="string">&quot;.cache&quot;</span>);</span><br><span class="line">    File file = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ConfigUtils.isNotEmpty(filename)) &#123;</span><br><span class="line">        file = <span class="keyword">new</span> File(filename);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists() &amp;&amp; file.getParentFile() != <span class="keyword">null</span> &amp;&amp; !file.getParentFile().exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!file.getParentFile().mkdirs()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid registry store file &quot;</span> + file + <span class="string">&quot;, cause: Failed to create directory &quot;</span> + file.getParentFile() + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.file = file;</span><br><span class="line">    loadProperties();</span><br><span class="line">    notify(url.getBackupUrls());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-FailbackRegistry-register-URL"><a href="#4-FailbackRegistry-register-URL" class="headerlink" title="4. FailbackRegistry.register(URL)"></a>4. FailbackRegistry.register(URL)</h3>registry.register(registedProviderUrl); 进行服务的注册将暴露的服务信息注册到注册中心，并且将已经注册的服务URL缓存到ZookeeperRegistry.registered 已注册服务的缓存中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">FailbackRegistry.register</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行服务注册逻辑的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (destroyed.get())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用AbstractRegistry.register进行服务对应URL的缓存</span></span><br><span class="line">    <span class="keyword">super</span>.register(url);</span><br><span class="line">    failedRegistered.remove(url);</span><br><span class="line">    failedUnregistered.remove(url);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 向服务器端发送注册请求，将服务注册到注册中心，可以使用各个注册协议(注册中心)的实现 此处使用zookeeper  ZookeeperRegistry.doRegister</span></span><br><span class="line">        doRegister(url);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Throwable t = e;</span><br><span class="line">        <span class="comment">// 如果开启了启动时检测，则直接抛出异常</span></span><br><span class="line">        <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class="line">        <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">        <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">            <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                t = t.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to register &quot;</span> + url + <span class="string">&quot; to registry &quot;</span> + getUrl().getAddress() + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Failed to register &quot;</span> + url + <span class="string">&quot;, waiting for retry, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将失败的注册请求记录到失败列表，定时重试</span></span><br><span class="line">        failedRegistered.add(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">AbstractRegistry.register</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;register url == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Register: &quot;</span> + url);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存已经注册的服务</span></span><br><span class="line">    registered.add(url);</span><br><span class="line">&#125;</span><br><span class="line">ZookeeperRegistry.doRegister</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 此处为具体服务暴露的代码 toUrlPath 根据URL生成写入zk的路径信息</span></span><br><span class="line">        zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Failed to register &quot;</span> + url + <span class="string">&quot; to zookeeper &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12、Dubbo使用的设计模式"><a href="#12、Dubbo使用的设计模式" class="headerlink" title="12、Dubbo使用的设计模式"></a>12、Dubbo使用的设计模式</h2><h3 id="1-工厂方法模式"><a href="#1-工厂方法模式" class="headerlink" title="1. 工厂方法模式"></a>1. 工厂方法模式</h3>CacheFactory的实现采用的是工厂方法模式。CacheFactory接口定义getCache方法，然后定义一个AbstractCacheFactory抽象类实现CacheFactory，并将实际创建cache的createCache方法分离出来，并设置为抽象方法。这样具体cache的创建工作就留给具体的子类去完成。<h3 id="2-责任链模式"><a href="#2-责任链模式" class="headerlink" title="2. 责任链模式"></a>2. 责任链模式</h3>Dubbo的调用链组织是用责任链模式串连起来的。责任链中的每个节点实现Filter接口，然后由ProtocolFilterWrapper，将所有Filter串连起来。Dubbo的许多功能都是通过Filter扩展实现的。<br>以 Provider 提供的调用链为例， 具体的调用链代码是在 ProtocolFilterWrapper 的 buildInvokerChain 完成的，具体 是将注解中含有 group=provider 的 Filter 实现，按照 order 排序，最后的调用顺序是:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EchoFilter -&gt; ClassLoaderFilter -&gt; GenericFilter -&gt; ContextFilter -&gt; Exe cuteLimitFilter -&gt; TraceFilter -&gt; TimeoutFilter -&gt; MonitorFilter -&gt; Exce ptionFilter</span><br></pre></td></tr></table></figure>
更确切地说，这里是装饰器和责任链模式的混合使用。例如，EchoFilter 的作用是判断 是否是回声测试请求，是的话直接返回内容，这是一种责任链的体现。而像 ClassLoaderFilter 则只是在主功能上添加了功能，更改当前线程的 ClassLoader，这 是典型的装饰器模式。<h3 id="3-观察者模式"><a href="#3-观察者模式" class="headerlink" title="3. 观察者模式"></a>3. 观察者模式</h3>Dubbo 的 Provider 启动时，需要与注册中心交互，先注册自己的服务，再订阅自己的 服务，订阅时，采用了观察者模式，开启一个 listener。注册中心会每 5 秒定时检查是 否有服务更新，如果有更新，向该服务的提供者发送一个 notify 消息，provider 接受 到 notify 消息后，即运行 NotifyListener 的 notify 方法，执行监听器方法。<h3 id="4-修饰器模式"><a href="#4-修饰器模式" class="headerlink" title="4. 修饰器模式"></a>4. 修饰器模式</h3>Dubbo 在启动和调用阶段都大量使用了装饰器模式。比如ProtocolFilterWrapper类是对Protocol类的修饰。在export和refer方法中，配合责任链模式，把Filter组装成责任链，实现对Protocol功能的修饰。其他还有ProtocolListenerWrapper、 ListenerInvokerWrapper、InvokerWrapper等。修饰器模式是一把双刃剑，一方面用它可以方便地扩展类的功能，而且对用户无感，但另一方面，过多地使用修饰器模式不利于理解，因为一个类可能经过层层修饰，最终的行为已经和原始行为偏离较大。<h3 id="5-代理模式"><a href="#5-代理模式" class="headerlink" title="5. 代理模式"></a>5. 代理模式</h3>Dubbo consumer使用Proxy类创建远程服务的本地代理，本地代理实现和远程服务一样的接口，并且屏蔽了网络通信的细节，使得用户在使用本地代理的时候，感觉和使用本地服务一样。<h2 id="13、Dubbo优雅关机"><a href="#13、Dubbo优雅关机" class="headerlink" title="13、Dubbo优雅关机"></a>13、Dubbo优雅关机</h2>优雅停机主要用在服务版本迭代上线的过程中，比如我们发布了新的服务版本，经常性是直接替换线上正在跑的服务，这个时候如果在服务切换的过程中老的服务没有正常关闭的话，容易造成内存清理问题，所以优雅停机也是重要的一环。<br>Dubbo的优雅停机是依赖于JDK的ShutdownHook函数，下面先了解一下JDK的ShutdownHook函数会在哪些时候生效：</li>
</ol>
<ul>
<li> 程序正常退出</li>
<li> 程序中使用System.exit()退出JVM</li>
<li> 系统发生OutofMemory异常</li>
<li> 使用kill pid干掉JVM进程的时候（kill -9时候是不能触发ShutdownHook生效的）<br>用户可以自行调用ProtocolConfig.destroyAll()来主动进行优雅停机，可见我们该从这方法入手：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">voiddestroyAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 1.关闭所有已创建注册中心</span></span><br><span class="line">    AbstractRegistryFactory.destroyAll();</span><br><span class="line">    ExtensionLoader&lt;Protocol&gt;loader = ExtensionLoader.getExtensionLoader(Protocol.class);</span><br><span class="line">   <span class="keyword">for</span>(StringprotocolName : loader.getLoadedExtensions()) &#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           Protocol protocol = loader.getLoadedExtension(protocolName);</span><br><span class="line">           <span class="keyword">if</span>(protocol !=<span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 2.关闭协议类的扩展点</span></span><br><span class="line">               protocol.destroy();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">           logger.warn(t.getMessage(),t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
该方法主要做两件事情：</li>
</ul>
<ol>
<li>和注册中心断连</li>
<li>关闭协议暴露（包括provider和consumer）<br>步骤一简单来说就是通过AbstractRegistryFactory.destroyAll()来“撤销”在所有注册中心注册的服务<br>步骤二是关闭自己暴露的服务和自己对下游服务的调用。假设我们使用的是dubbo协议，protocol.destroy()其实会调用DubboProtocol#destroy方法，该方法部分摘要如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//关停所有的Server，作为provider将不再接收新的请求</span></span><br><span class="line">       <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(serverMap.keySet())) &#123;          </span><br><span class="line">           <span class="comment">//HeaderExchangeServer</span></span><br><span class="line">           ExchangeServer server = serverMap.remove(key);</span><br><span class="line">           <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                       logger.info(<span class="string">&quot;Close dubbo server: &quot;</span> + server.getLocalAddress());</span><br><span class="line">                   &#125;</span><br><span class="line">                   server.close(getServerShutdownTimeout());</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                   logger.warn(t.getMessage(), t);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//关停所有的Client，作为consumer将不再发送新的请求</span></span><br><span class="line">       <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(referenceClientMap.keySet())) &#123;</span><br><span class="line">           ExchangeClient client = referenceClientMap.remove(key);</span><br><span class="line">           <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                       logger.info(<span class="string">&quot;Close dubbo connect: &quot;</span> + client.getLocalAddress() + <span class="string">&quot;--&gt;&quot;</span> + client.getRemoteAddress());</span><br><span class="line">                   &#125;</span><br><span class="line">                   client.close();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                   logger.warn(t.getMessage(), t);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//对于幽灵客户端的处理逻辑暂时先忽略</span></span><br><span class="line">       stubServiceMethodsMap.clear();</span><br><span class="line">       <span class="keyword">super</span>.destroy();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//HeaderExchangeServer.close(timeout)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> max = (<span class="keyword">long</span>) timeout;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">           <span class="keyword">if</span> (getUrl().getParameter(Constants.CHANNEL_SEND_READONLYEVENT_KEY, <span class="keyword">false</span>))&#123;</span><br><span class="line">               sendChannelReadOnlyEvent();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//作为server在关闭的时候很有可能仍然有任务在进行中，这时候这个timeout的时间就是用来等待相应处理结束的，每隔10ms进行一次重试，直到最后超时</span></span><br><span class="line">           <span class="keyword">while</span> (HeaderExchangeServer.<span class="keyword">this</span>.isRunning() </span><br><span class="line">                   &amp;&amp; System.currentTimeMillis() - start &lt; max) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">10</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   logger.warn(e.getMessage(), e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       doClose();</span><br><span class="line">       <span class="comment">//NettyServer</span></span><br><span class="line">       server.close(timeout);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//关闭处理心跳任务的定时器</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       closed = <span class="keyword">true</span>;</span><br><span class="line">       stopHeartbeatTimer();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           scheduled.shutdown();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           logger.warn(t.getMessage(), t);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//AbstractService.close()</span></span><br><span class="line">   <span class="comment">//作者的本意就是在这里关闭掉业务线程池，这里提到的业务线程池也就是dubbo处理所有自定义业务使用的线程池，关闭这个线程池十分重要，但是老版本的代码在这里有BUG</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">       ExecutorUtil.gracefulShutdown(executor ,timeout);</span><br><span class="line">       <span class="comment">//close方法就是强制关闭业务线程池，并且关闭NettyServer中相关Channel</span></span><br><span class="line">       close();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gracefulShutdown</span><span class="params">(Executor executor, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!(executor <span class="keyword">instanceof</span> ExecutorService) || isShutdown(executor)) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">final</span> ExecutorService es = (ExecutorService) executor;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//不再接收新的任务，将原来未执行完的任务执行完</span></span><br><span class="line">           es.shutdown();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SecurityException ex2) &#123;</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (NullPointerException ex2) &#123;</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">try</span> &#123;<span class="comment">//如果到达timeout时间之后仍然没有关闭任务，就直接调用shutdownNow，强制关闭所有任务</span></span><br><span class="line">           <span class="keyword">if</span>(! es.awaitTermination(timeout, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">               es.shutdownNow();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">           es.shutdownNow();</span><br><span class="line">           <span class="comment">//不要生吞InterruptedException，所以在本地调用中依然将本线程的interrupted置位，以便上层能够发现</span></span><br><span class="line">           Thread.currentThread().interrupt();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果到这里都没有关闭成功的话，就重新开线程关闭业务线程池</span></span><br><span class="line">       <span class="keyword">if</span> (!isShutdown(es))&#123;</span><br><span class="line">           newThreadToCloseExecutor(es);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
我们可以看到顺序，是先关闭provider，再关闭consumer，这理解起来也简单，不先关闭provider，就可能会一直有对下游服务的调用。代码中的getServerShutdownTimeout()是获取“provider服务关闭的最长等待时间”的配置，即通过dubbo.service.shutdown.wait来设置的值，单位毫秒，默认是10秒钟，HeaderExchangeServer#close方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        doClose();</span><br><span class="line">        channel.close(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//HeaderExchangeChannel.clse()</span></span><br><span class="line">    <span class="comment">//关闭心跳处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stopHeartbeatTimer();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// graceful close</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        closed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//这里作者的本意是看一下客户端是否有发出去的请求，但是还没有收到相应的，然后等到timeout时间看请求是否返回</span></span><br><span class="line">        <span class="comment">//但是因为DefaultFuture在发送请求时候的key是成员变量channel，而不是HeaderExchangeChannel.this，所以这代码有BUG</span></span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">while</span> (DefaultFuture.hasFuture(HeaderExchangeChannel.<span class="keyword">this</span>) </span><br><span class="line">                    &amp;&amp; System.currentTimeMillis() - start &lt; timeout) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    logger.warn(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.warn(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="14、扩展：如何自己设计一个类似dubbo的rpc框架？"><a href="#14、扩展：如何自己设计一个类似dubbo的rpc框架？" class="headerlink" title="14、扩展：如何自己设计一个类似dubbo的rpc框架？"></a>14、扩展：如何自己设计一个类似dubbo的rpc框架？</h2>可以从几方面去思考：</li>
<li>服务订阅发布（注册中心）</li>
<li>服务路由</li>
<li>负载均衡（随机、轮询、最少活跃调用数、一致性哈希负载均衡）</li>
<li>集群容错（失败重试、限流降级）</li>
<li>服务调用（同步调用、异步调用、参数回调、事件通知）</li>
<li>多协议</li>
<li>序列化方式</li>
<li>统一配置</li>
<li>动态代理</li>
</ol>
	
		</div>
		
		<div id="current-post-cover" data-scr="/img/cart_cover.jpg"></div>

		<!-- relate post, comment...-->
		<div class="investment-container">
			<div class="investment-header">
				<div class="investment-title-1">
					<div class="on">相关文章</div>
					<div>评论</div>
					<div>分享</div>
				</div>
				<div class="investment-title-2">	            
					
	<span>
		<a id="totop-post-page">返回顶部</a>
		
			<a href="/2021/05/12/notes/algorithms/Big-Data/" title="Big-Data" rel="prev">
				&laquo;上一篇
			</a>
		
			
	</span>


      		
				</div>	
			</div>
			
			<div class="investment-content">
				<div class="investment-content-list">
					

<div class="relate-post">
	
		<ul>
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/05/12/notes/framework/MyBatis/" title="MyBatis">
								MyBatis			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 12日, 2021				
							</p>
							<p class="relate-post-content">
								MyBatis介绍在介绍MyBatis之前先简单了解几个概念：ORM，JPA。
ORMORM（Object-Relationship-Mapping）：是对象关系映射的意思，它是一种思想，是指将数据库中的每一行数据用对象的形式表现出来...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/05/12/notes/framework/MyBatis/" title="MyBatis">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="MyBatis"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/05/12/notes/framework/Nginx/" title="Nginx">
								Nginx			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 12日, 2021				
							</p>
							<p class="relate-post-content">
								Nginx是什么？Nginx是一个开源且高性能、可靠的HTTP中间件、代理服务其他的HTTP服务：

HTTPD-Apache基金会
IIS-微软
GWS-Google(不对外开放)我们为什么选择Nginx？1. IO多路复用epol...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/05/12/notes/framework/Nginx/" title="Nginx">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="Nginx"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/05/12/notes/framework/Solr/" title="Solr">
								Solr			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 12日, 2021				
							</p>
							<p class="relate-post-content">
								solr原理索引Solr/Lucene采用的是一种反向索引（倒排索引），所谓反向索引：就是从关键字到文档的映射过程，保存这种映射这种信息的索引称为反向索引

左边保存的是字符串序列
右边是字符串的文档（Document）编号链表，称为...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/05/12/notes/framework/Solr/" title="Solr">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="Solr"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/05/12/notes/framework/Tomcat/" title="Tomcat">
								Tomcat			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 12日, 2021				
							</p>
							<p class="relate-post-content">
								Tomcat是什么？Tomcat 服务器Apache软件基金会项目中的一个核心项目，是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/05/12/notes/framework/Tomcat/" title="Tomcat">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="Tomcat"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/05/12/notes/framework/Kafka/" title="Kafka">
								Kafka			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 12日, 2021				
							</p>
							<p class="relate-post-content">
								Kafka介绍Kafka是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/05/12/notes/framework/Kafka/" title="Kafka">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="Kafka"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/05/12/notes/framework/netty/" title="netty">
								netty			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 12日, 2021				
							</p>
							<p class="relate-post-content">
								1、IO和NIO
面向流和面向Buffer传统IO和Java NIO最大的区别是传统的IO是面向流，NIO是面向BufferJava IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/05/12/notes/framework/netty/" title="netty">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="netty"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/05/12/notes/framework/Zookeeper/" title="Zookeeper">
								Zookeeper			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 12日, 2021				
							</p>
							<p class="relate-post-content">
								ZooKeeper 是什么？ZooKeeper 是一个开源的分布式协调服务。它是一个为分布式应用提供一致性服务的软件，分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/05/12/notes/framework/Zookeeper/" title="Zookeeper">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="Zookeeper"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/05/12/notes/framework/Spring/" title="Spring">
								Spring			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 12日, 2021				
							</p>
							<p class="relate-post-content">
								Spring 介绍什么是spring?Spring是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/JavaEE full-sta...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/05/12/notes/framework/Spring/" title="Spring">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="Spring"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/07/19/notes/%E8%AE%A4%E8%AF%81%E5%AE%89%E5%85%A8%E6%80%A7/" title="">
											
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								七月 19日, 2021				
							</p>
							<p class="relate-post-content">
								认证
认证（Authentication）
系统如何正确分辨出操作用户的真实身份？


通信信道上的认证：你和我建立通信连接之前，要先证明你是谁。在网络传输（Network）场景中的典型是基于 SSL/TLS 传输安全层的认证。
通信...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/07/19/notes/%E8%AE%A4%E8%AF%81%E5%AE%89%E5%85%A8%E6%80%A7/" title="">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt=""/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/07/19/notes/java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="Java虚拟机">
								Java虚拟机			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								七月 19日, 2021				
							</p>
							<p class="relate-post-content">
								JVM内存结构 VS Java内存模型 VS Java对象模型JVM内存结构Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，其中有些区域随着虚拟机...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/07/19/notes/java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="Java虚拟机">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="Java虚拟机"/>
							</a>
						</div>
					</li>												
			
		</ul>
	
</div>	
				</div>
				<div class="investment-content-list">
					<div class="layout-comment">

	
		<div class="config-info">
			Please check the parameter of <b>comment</b> in config.yml of hexo-theme-Annie!
		</div>	
	

</div>
				</div>
				<div class="investment-content-list">
					<div class="layout-share">
	
	

		
			
			<!-- socialShare share -->
			<div class="social-share"></div>

<!--  css & js -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
<script async src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
			
		
		
	
</div>


				</div>
			</div>	
		</div>
	</div>
</div>

<!-- show math formula -->



	 
	
<script src="/plugin/clipboard/clipboard.js"></script>

	<script>
		// Copy code !
	    function preprocessing() {
	        $("#article-content .highlight").each(function() {
	            $(this).wrap('<div id="post-code"></div>');
	        })

	        $("#article-content #post-code").each(function() {
	            $(this).prepend('<nav class="copy-nav"><span><i class="code-language"></i></span></nav>');
	        })

	        $("#article-content .copy-nav").each(function() {
	            let languageClass = $(this).next().attr('class'),
	                language = ((languageClass.length > 9) && (languageClass != null)) ? languageClass.substr(10) : "none"; //why 9? Need to check language?

	            $(this).find('.code-language').text(language);
	            $(this).append('<span class="copy-btn icon-paste"></span>');
	        });
	    }

		function copy() {
		    $('#article-content #post-code').each(function(i) {
		        let codeCopyId = 'codeCopy-' + i;

		        let codeNode = $(this).find('.code'),
		            copyButton = $(this).find('.copy-btn');

		        codeNode.attr('id', codeCopyId);
		        copyButton.attr('data-clipboard-target-id', codeCopyId);
		    })
   
			let clipboard = new ClipboardJS('.copy-btn', {
					target: function(trigger) {
						return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
					}
		      	});

			//pure js
			function showTooltip(elem, msg) {		   
				elem.setAttribute('aria-label', msg);
				elem.setAttribute('class', 'copy-btn icon-clipboard1');
				setTimeout(function() {
					elem.setAttribute('class', 'copy-btn icon-paste');
				}, 2000);
			}

			clipboard.on('success', function(e) {
			    e.clearSelection();
			    console.info('Action:', e.action);		   
			    console.info('Trigger:', e.trigger);
			    showTooltip(e.trigger, 'Copied!');   
			});
			
			clipboard.on('error', function(e) {
			    console.error('Action:', e.action);
			    console.error('Trigger:', e.trigger);
			});
		}
		
		(function copyCode(){
			if ($('.layout-post').length) {
			    preprocessing();
			    copy();
			} 
		})();
	</script>






<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">


<script src="/plugin/fancybox/jquery.fancybox.js"></script>


<script type="text/javascript">
	(function gallerySet(){
		let titleID = $('.article-title a'),
			imageID = $('.article-content img'),
			videoID = $('.article-content video');
		
		let postTitle = titleID.text() ? titleID.text() : "No post title!";
		
		imageID.each(function() {
			let imgPath = $(this).attr('src'),
				imgTitle = $(this).attr('alt') ? $(this).attr('alt') : "No image description!";
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox="gallery" data-caption="《 ' + postTitle + ' 》' + imgTitle + '"href="' + imgPath + '"> </a>');
		});
		
		videoID.each(function() {
			let videoPath = $(this).attr('src');
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox href=" ' + videoPath + ' "> </a>');
		});
		
		//TODO：支持html5 video

		if($('#layout-post').length) {
			$('[data-fancybox="gallery"]').fancybox({
				loop: true,
				buttons: [
					"zoom",
					"share",
					"slideShow",
					"fullScreen",
					//"download",
					"thumbs",
					"close"
				],
				protect: true
			});
		}
	})();
</script>
		</main>

		<!--footer-->
		<footer>
	<div id="navigation-show">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	

	
</ul>
	</div>

	<div class="copyright">
		<p>
			 
				&copy;2021, content by Shawceng. All Rights Reserved.
			
			
				<a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> Theme <a href="https://github.com/Sariay/hexo-theme-Annie" title="Annie" target="_blank" rel="noopener">Annie</a> by Sariay.
			
		</p>
		<p>
			

	<!-- busuanzi -->
	<!-- busuanzi -->



			<a href="javascript:zh_tran('s');" class="zh_click" id="zh_click_s">简体</a> 
			<a href="javascript:zh_tran('t');" class="zh_click" id="zh_click_t">繁體</a>				
		</p>
	</div>		
</footer>
		
	<!-- Local or hitokoto! -->
 
	<!-- 现代写法，推荐 -->
	<!-- 兼容低版本浏览器 (包括 IE)，可移除 -->
	<script src="https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js"></script>
	<!--End-->
	<script>
		(function motto(){
			fetch('https://v1.hitokoto.cn/?c=d')
				.then(function (res){
				return res.json();
			}).then(function (data) {
				$("#motto-content").html( data.hitokoto?data.hitokoto:'请刷新...' );
				
				let	mottoAuthor =' ';
					mottoAuthor += data.creator?data.creator:'一言';
					mottoAuthor += "　/　";
					mottoAuthor += data.from?data.from:'一言官网';
					
				$("#motto-author").html( mottoAuthor );
			})
			.catch(function (err) {
				console.error(err);
			})			
		})();
	</script>



<!-- love effect -->


<!-- back to top -->

	<div id="totop">
	<span class="icon-circle-up"></span>
</div>



<!-- site analysis -->


	<!-- site-analysis -->
	
	
	
	
	
 

<!-- leancloud -->


	<!-- leancloud -->
	<!--
	时间：2018-11-27
	描述：
		文章访问量：visitors
		文章喜欢量：likes	
		文章排行榜：topNPost
		其他得说明：
			01-Cookie相关的函数 
				https://blog.csdn.net/somehow1002/article/details/78511541（Author：somehow1002）
			02-visitors相关的函数 
				https://blog.csdn.net/u013553529/article/details/63357382（Author：爱博客大伯）
				https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html（Author：夏末）
			03-topNPost相关的函数
				https://hoxis.github.io/hexo-next-read-rank.html（Author：hoxis）
			04-likes相关的函数，
				参考了01 & 02进行简单的设计与实现
-->


	

  



<script src="/plugin/chinese/chinese.js"></script>
<script src="/plugin/imagelazyloader/yall.min.js"></script>
<script src="/plugin/imageloaded/imagesloaded.pkgd.min.js"></script>
<script src="/plugin/nicescroll/jquery.nicescroll.js"></script>
<script src="/plugin/resizediv/resizediv.js"></script>
<script src="/js/main.js"></script>

	</body>	
</html>