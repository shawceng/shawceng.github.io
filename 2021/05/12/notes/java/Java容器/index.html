<!--
	作者：Sariay
	时间：2018-08-26
	描述：There may be a bug, but don't worry, Qiling(器灵) says that it can work normally! aha!
-->
<!DOCTYPE html>
<html class="html-loading">
		

<head>
	<meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <title>
    
      Java容器 | Shawceng的技术手札
    
  </title>
  <meta name="author" content="Shawceng">
  <meta name="keywords" content="" />
  <meta name="description" content="" />
	<!-- favicon -->
  <link rel="shortcut icon" href="/img/favicon.ico">

  <!-- css -->
  
<link rel="stylesheet" href="/css/Annie.css">

  
  <!-- jquery -->
	
<script src="/plugin/jquery/jquery.min.js"></script>


<script>
    const CONFIG_BGIMAGE = {
      mode: 'random',
      normalSrc: '/img/header-bg.jpg',
      randomYouMax: 110,
      randomYouSrc: 'https://sariay.github.io/Random-img/',
	  randomOtherSrc: 'https://api.berryapi.net/?service=App.Bing.Images&day=-0',
	  preloaderEnable: true
    }
	
    const CONFIG_LEACLOUD_COUNT = {
      enable: false,
	  appId: 'AU8...',
	  appKey: '4cU...',
	  serverURLs: 'http' || ' '
    }
  </script>
<meta name="generator" content="Hexo 5.3.0"></head>
	<body>
		<!-- Preloader -->

	<div id="preloader">
		<div class="pre-container">
			
				<div class="spinner">
					<div class="double-bounce1"></div>
					<div class="double-bounce2"></div>
				</div>
						
		</div>
	</div>


<!-- header -->
<header class="fixbackground bg-pan-br">
	<div class="mask">
		<!-- motto -->
		<div class="h-body">	
			
				<div class="motto text-shadow-pop-left">
					<p class="content" id="motto-content">获取中...</p>
					<p>-<p>
					<p class="author" id="motto-author">Just a minute...</p>
				</div>
			
		</div>
		
		<!-- others: such as time... -->			
		<div class="h-footer">
			<a href="javascript:;" id="read-more" class="scroll-down">
				<span class="icon-anchor1 animation-scroll-down"></span>
			</a>
		</div>
	</div>
</header>

<div id="navigation-hide">
	<!-- Progress bar -->
	<div id="progress-bar"></div>

	<!-- Progress percent -->
	<div id="progress-percentage"><span>0.0%</span></div>

	<div class="toc-switch"><span class="switch-button">目录</span></div>

	<!-- Page title -->
	<p>
		
			「Java容器」
		
	</p>

	
	

	<!-- Nav trigger for navigation-H-->
	<a class="nav-trigger"><span></span></a>
</div>

<!-- Navigation in div(id="navigation-H") -->
<nav class="nav-container" id="cd-nav">
	<div class="nav-header">
		<span class="logo"> 
			<img src="/img/logo.png">
		</span>
		<a href="javascript:;" class="nav-close"></a>
	</div>
	
	<div class="nav-body">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	

	
</ul>
	</div>
	
	<div class="nav-footer">
		<ul id="global-social">
	
		<li>
			<a href="http://github.com/shawceng" target="_blank">
				<span class="icon-github"></span>
			</a>
		</li>
			
</ul>

	</div>
</nav>
			
		<!--main-->
		<main>
			<!--
	时间：2018-11-17
	描述：
		插件名称：katelog.min.js
		插件作者：KELEN
		插件来源: https://github.com/KELEN/katelog
-->

	
		<div class="layout-toc">
			<div id="layout-toc">
				<div class="k-catelog-list" id="catelog-list" data-title="文章目录"></div>
			</div>
		</div>

		
<script src="/plugin/toc/katelog.min.js"></script>


		
	 

<div class="layout-post">
	<div id="layout-post">
		<div class="article-title">
			
	<a href="/2021/05/12/notes/java/Java%E5%AE%B9%E5%99%A8/" itemprop="url">
		Java容器
	</a>

		</div>

		<div class="article-meta">
			<span>
				<i class="icon-calendar1"></i>
				
				




	更新于

	<a href="/2021/05/12/notes/java/Java%E5%AE%B9%E5%99%A8/" itemprop="url">
		<time datetime="2021-05-12T03:58:17.000Z" itemprop="dateUpdated">
	  		2021-05-12
	  </time>
	</a> 



			</span>
			<span>
						
			</span>
			
			



		</div>

		<div class="article-content" id="article-content">
			<h2 id="Java集合类框架图"><a href="#Java集合类框架图" class="headerlink" title="Java集合类框架图"></a>Java集合类框架图</h2><p><img src="/images/Java-16.png"></p>
<h3 id="Java集合类框架的基本接口有哪些？"><a href="#Java集合类框架的基本接口有哪些？" class="headerlink" title="Java集合类框架的基本接口有哪些？"></a>Java集合类框架的基本接口有哪些？</h3><p>总共有两大接口：Collection 和Map ，一个元素集合，一个是键值对集合； 其中List和Set接口继承了Collection接口，一个是有序元素集合，一个是无序元素集合； 而ArrayList和 LinkedList 实现了List接口，HashSet实现了Set接口，这几个都比较常用； HashMap 和HashTable实现了Map接口，并且HashTable是线程安全的，但是HashMap性能更好；</p>
<h2 id="HashSet和TreeSet区别"><a href="#HashSet和TreeSet区别" class="headerlink" title="HashSet和TreeSet区别"></a>HashSet和TreeSet区别</h2><p><strong>HashSet</strong></p>
<ol>
<li>不能保证元素的排列顺序，顺序有可能发生变化</li>
<li>不是同步的</li>
<li>集合元素可以是null,但只能放入一个null<br>当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。</li>
</ol>
<p><strong>TreeSet</strong></p>
<ol>
<li>TreeSet是SortedSet接口的唯一实现类</li>
<li>TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序 和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象<h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2></li>
</ol>
<ul>
<li><strong>底层实现</strong>：ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构，ArrayList需要扩容、LinkedList不需要</li>
<li><strong>时间复杂度</strong>：对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针</li>
<li><strong>使用场景</strong>：LinkedList是个双向链表，它同样可以被当作栈、队列或双端队列来使用。<h2 id="讲一下LinkedHashMap"><a href="#讲一下LinkedHashMap" class="headerlink" title="讲一下LinkedHashMap"></a>讲一下LinkedHashMap</h2>LinkedHashMap的实现就是HashMap+LinkedList的实现方式，以HashMap维护数据结构，以LinkList的方式维护数据插入顺序<br>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。<br>在遍历的时候会比HashMap慢TreeMap能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器<br>利用LinkedHashMap实现LRU算法缓存（</li>
</ul>
<ol>
<li>LinkedList首先它是一个Map，Map是基于K-V的，和缓存一致</li>
<li>LinkedList提供了一个boolean值可以让用户指定是否实现LRU）<h2 id="Java8-中HashMap的优化（引入红黑树的数据结构和扩容的优化）"><a href="#Java8-中HashMap的优化（引入红黑树的数据结构和扩容的优化）" class="headerlink" title="Java8 中HashMap的优化（引入红黑树的数据结构和扩容的优化）"></a>Java8 中HashMap的优化（引入红黑树的数据结构和扩容的优化）</h2></li>
<li>if (binCount &gt;= TREEIFY_THRESHOLD - 1)<br>当符合这个条件的时候，把链表变成treemap红黑树，这样查找效率从o(n)变成了o(log n) ，在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：</li>
<li>我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置<br>这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。</li>
</ol>
<p><strong>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</strong><br>hashMap 1.8 哈希算法例图2<br><img src="/images/Java-2.jpg"><br><strong>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”</strong></p>
<h2 id="Map遍历的keySet-和entrySet-性能差异原因"><a href="#Map遍历的keySet-和entrySet-性能差异原因" class="headerlink" title="Map遍历的keySet()和entrySet()性能差异原因"></a>Map遍历的keySet()和entrySet()性能差异原因</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">Set&lt;String&gt; set = map.keySet();` </span><br></pre></td></tr></table></figure>
<ol>
<li>keySet（）循环中通过key获取对应的value的时候又会调用getEntry（）进行循环。循环两次</li>
<li>entrySet（）直接使用getEntry（）方法获取结果，循环一次</li>
<li>所以 keySet（）的性能会比entrySet（）差点。所以遍历map的话还是用entrySet()来遍历<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> getForNullKey();</span><br><span class="line">       Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">   &#125;    </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HashMap中的indexFor方法"><a href="#HashMap中的indexFor方法" class="headerlink" title="HashMap中的indexFor方法"></a>HashMap中的indexFor方法</h2>在HashMap的工作原理，发现它调用了 indexFor(int h, int length) 方法来计算Entry对象保存在 table中的数组索引值：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
HashMap的初始容量和扩容都是以2的次方来进行的，那么length-1换算成二进制的话肯定所有位都为1，就比如2的3次方为8，length-1的二进制表示就是111， 而按位与计算的原则是两位同时为“1”，结果才为“1”，否则为“0”。所以h&amp; (length-1)运算从数值上来讲其实等价于对length取模，也就是h%length。<br>只有当数组长度为2的n次方时，那么length-1换算成二进制的话肯定所有位都为1,不同的key计算得出的index索引相同的几率才会较小，数据在数组上分布也比较均匀，碰撞的几率也小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。<h2 id="如何删除ArrayList里面的元素"><a href="#如何删除ArrayList里面的元素" class="headerlink" title="如何删除ArrayList里面的元素"></a>如何删除ArrayList里面的元素</h2>使用以下for循环使用remove()删除是有问题的，因为每次删除一个元素，后面元素往前移，数组大小也变小，会到数组下标越界异常<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; list1.size();i++)&#123;</span><br><span class="line">            list1.remove(i);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
推荐两种方法：</li>
<li>根据长度，不断删除第一个元素，<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; list1.size();i++)&#123;</span><br><span class="line">            list1.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li>使用迭代器(推荐)，不会导致数组长度变化而抛异常<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iter = list1.iterator();</span><br><span class="line">     <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">         Integer s = iter.next();</span><br><span class="line">         <span class="keyword">if</span>(s.equals(<span class="string">&quot;1&quot;</span>))&#123;</span><br><span class="line">             iter.remove();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h2 id="并发的HashMap为什么会引起死循环？"><a href="#并发的HashMap为什么会引起死循环？" class="headerlink" title="并发的HashMap为什么会引起死循环？"></a>并发的HashMap为什么会引起死循环？</h2>线程不安全的HashMap, HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，查找时会陷入死循环<br>在扩容resize（）方法中，调用transfer方法，把旧表中的元素添加到新表中，这也是引起死循环的根本原因所在<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; next = e.next; <span class="comment">// &lt;--假设线程一执行到这里就被调度挂起了</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">    e.next = newTable[i];</span><br><span class="line">    newTable[i] = e;</span><br><span class="line">    e = next;</span><br><span class="line">&#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
执行一：  线程A执行到transfer函数中（1）处挂起（transfer函数代码中有标注）。此时在线程A的栈中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = <span class="number">3</span></span><br><span class="line">next = <span class="number">7</span></span><br></pre></td></tr></table></figure>
执行二：线程B执行 transfer函数中的while循环，即会把原来的table变成新一table（线程B自己的栈中），再写入到内存,如下图（假设两个元素在新的hash函数下也会映射到同一个位置）<br><img src="/images/Java-9.jpg"><br>执行三： 线程A解挂，接着执行（看到的仍是旧表），即从transfer代码（1）处接着执行，当前的 e = 3, next = 7, 上面已经描述。</li>
<li>处理元素 3 ， 将 3 放入 线程A自己栈的新table中（新table是处于线程A自己栈中，是线程私有的，不肥线程2的影响），处理3后的图如下：<br><img src="/images/Java-10.jpg"></li>
<li>线程A再复制元素 7 ， <strong>当前 e = 7 ,而next值由于线程 B 修改了它的引用，所以next 为 3</strong> ，处理后的新表如下图<br><img src="/images/Java-11.jpg"></li>
<li>由于上面取到的next = 3, 接着while循环，即当前处理的结点为3， next就为null ，退出while循环，执行完while循环后，新表中的内容如下图：<br><img src="/images/Java-12.jpg"></li>
<li>当操作完成，执行查找时，会陷入死循环！<br>总结：多线程PUT操作时可能会覆盖刚PUT进去的值,扩容操作会让链表形成环形数据结构，形成死循环<h2 id="ConcurrentHashMap原理"><a href="#ConcurrentHashMap原理" class="headerlink" title="ConcurrentHashMap原理"></a>ConcurrentHashMap原理</h2>HashTable 在每次同步执行时都要锁住整个结构。ConcurrentHashMap 锁的方式是稍微细粒度的。 ConcurrentHashMap 将 hash 表分为 16 个桶（默认值）<br>Java7<br><img src="/images/Java-13.jpg"><br>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。<br>Java8<br><img src="/images/Java-14.jpg"><br>Java 8为进一步提高并发性，摒弃了分段锁的方案，而是直接使用一个大的数组。同时为了提高哈希碰撞下的寻址性能，Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(long(N))<br>Java 8的ConcurrentHashMap同样是通过Key的哈希值与数组长度取模确定该Key在数组中的索引。<br>对于put操作，如果Key对应的数组元素为null，则通过CAS操作将其设置为当前值。如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，则对该元素使用synchronized关键字申请锁，然后进行操作。如果该put操作使得当前链表长度超过一定阈值，则将该链表转换为树，从而提高寻址效率。<h2 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h2><h3 id="HashMap特性"><a href="#HashMap特性" class="headerlink" title="HashMap特性"></a>HashMap特性</h3>HashMap的特性：HashMap存储键值对，实现快速存取数据；允许null键/值；非同步；不保证有序(比如插入的顺序)。实现map接口。<h3 id="HashMap的原理，内部数据结构"><a href="#HashMap的原理，内部数据结构" class="headerlink" title="HashMap的原理，内部数据结构"></a>HashMap的原理，内部数据结构</h3>HashMap是基于hashing的原理，底层使用哈希表（数组 + 链表）实现。里边最重要的两个方法put、get，使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。<br>存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。<h3 id="HashMap的hash函数原理"><a href="#HashMap的hash函数原理" class="headerlink" title="HashMap的hash函数原理"></a>HashMap的hash函数原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Java 8中这一步做了优化，只做一次16位右位移异或混合，而不是四次，但原理是不变的。<br>优化了高位运算的算法，<strong>通过hashCode()的高16位异或低16位实现的</strong>，主要是从速度、功效、质量来考虑的<h3 id="讲一下-HashMap-中-put-方法过程"><a href="#讲一下-HashMap-中-put-方法过程" class="headerlink" title="讲一下 HashMap 中 put 方法过程"></a>讲一下 HashMap 中 put 方法过程</h3></li>
<li>对key的hashCode做hash操作，然后再计算在bucket中的index（1.5 HashMap的哈希函数）； </li>
<li>如果没碰撞直接放到bucket里； </li>
<li>如果碰撞了，以链表的形式存在buckets后； </li>
<li>如果节点已经存在就替换old value(保证key的唯一性) </li>
<li>如果bucket满了(超过阈值，阈值=loadfactor*current capacity，load factor默认0.75)，就要resize。<h3 id="get-方法的工作原理"><a href="#get-方法的工作原理" class="headerlink" title="get()方法的工作原理"></a>get()方法的工作原理</h3>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表中查找对应的节点。<h3 id="HashMap的put-方法流程"><a href="#HashMap的put-方法流程" class="headerlink" title="HashMap的put()方法流程"></a>HashMap的put()方法流程</h3><img src="/images/Java-23.png"><h3 id="HashMap中hash函数怎么是是实现的？还有哪些-hash-的实现方式？"><a href="#HashMap中hash函数怎么是是实现的？还有哪些-hash-的实现方式？" class="headerlink" title="HashMap中hash函数怎么是是实现的？还有哪些 hash 的实现方式？"></a>HashMap中hash函数怎么是是实现的？还有哪些 hash 的实现方式？</h3></li>
<li>对key的hashCode做hash操作（高16bit不变，低16bit和高16bit做了一个异或）； </li>
<li>h &amp; (length-1); //通过位操作得到下标index。<br>还有数字分析法、平方取中法、分段叠加法、 除留余数法、 伪随机数法。<h3 id="Java8-HashMap扩容时为什么不需要重新hash？"><a href="#Java8-HashMap扩容时为什么不需要重新hash？" class="headerlink" title="Java8 HashMap扩容时为什么不需要重新hash？"></a>Java8 HashMap扩容时为什么不需要重新hash？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123; </span><br><span class="line">                              if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                  loHead &#x3D; e;</span><br><span class="line">                              else</span><br><span class="line">                                  loTail.next &#x3D; e;</span><br><span class="line">                              loTail &#x3D; e;</span><br><span class="line">                          &#125;</span><br><span class="line">                          else &#123;</span><br><span class="line">                              if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                  hiHead &#x3D; e;</span><br><span class="line">                              else</span><br><span class="line">                                  hiTail.next &#x3D; e;</span><br><span class="line">                              hiTail &#x3D; e;</span><br><span class="line">                          &#125;</span><br></pre></td></tr></table></figure>
可以看到它是通过将数据的hash与扩容前的长度进行与操作，根据<code>e.hash &amp; oldCap</code>的结果来判断，如果是0，说明位置没有发生变化，如果不为0，说明位置发生了变化，而且新的位置=老的位置+老的数组长度。<br>比如数据B它经过hash之后的值为 1111，在扩容之前数组长度是8，数据B的位置是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n-1)&amp;hash &#x3D; (8-1) &amp; 1111 &#x3D; 111 &amp; 1111 &#x3D; 0111</span><br></pre></td></tr></table></figure>
扩容之后，数组长度是16，重新计算hash位置是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n-1)&amp;hash &#x3D; (16-1) &amp; 1111 &#x3D; 1111 &amp; 1111 &#x3D; 1111</span><br></pre></td></tr></table></figure>
可见数据B的位置发生了变化，同时新的位置和原来的位置关系是：</li>
</ol>
<p><strong>新的位置（1111）= 1000+原来的位置（0111）=原来的长度（8）+原来的位置（0111）</strong><br>继续看一下e.hash &amp; oldCap的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.hash &amp; oldCap &#x3D; 1111 &amp; 8 &#x3D; 1111 &amp; 1000 &#x3D; 1000 (!&#x3D;0)</span><br></pre></td></tr></table></figure>
<h3 id="HashMap-怎样解决冲突？"><a href="#HashMap-怎样解决冲突？" class="headerlink" title="HashMap 怎样解决冲突？"></a>HashMap 怎样解决冲突？</h3><p>HashMap中处理冲突的方法实际就是链地址法，内部数据结构是数组+单链表。</p>
<h4 id="扩展问题1：当两个对象的hashcode相同会发生什么？"><a href="#扩展问题1：当两个对象的hashcode相同会发生什么？" class="headerlink" title="扩展问题1：当两个对象的hashcode相同会发生什么？"></a>扩展问题1：当两个对象的hashcode相同会发生什么？</h4><p>因为两个对象的Hashcode相同，所以它们的bucket位置相同，会发生“碰撞”。HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。</p>
<h4 id="扩展问题2：抛开-HashMap，hash-冲突有那些解决办法？"><a href="#扩展问题2：抛开-HashMap，hash-冲突有那些解决办法？" class="headerlink" title="扩展问题2：抛开 HashMap，hash 冲突有那些解决办法？"></a>扩展问题2：抛开 HashMap，hash 冲突有那些解决办法？</h4><p>开放定址法、链地址法、再哈希法。</p>
<h3 id="如果两个键的hashcode相同，你如何获取值对象？"><a href="#如果两个键的hashcode相同，你如何获取值对象？" class="headerlink" title="如果两个键的hashcode相同，你如何获取值对象？"></a>如果两个键的hashcode相同，你如何获取值对象？</h3><p>重点在于理解hashCode()与equals()。<br>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。两个键的hashcode相同会产生碰撞，则利用key.equals()方法去链表或树（java1.8）中去查找对应的节点。</p>
<h3 id="针对-HashMap-中某个-Entry-链太长，查找的时间复杂度可能达到-O-n-，怎么优化？"><a href="#针对-HashMap-中某个-Entry-链太长，查找的时间复杂度可能达到-O-n-，怎么优化？" class="headerlink" title="针对 HashMap 中某个 Entry 链太长，查找的时间复杂度可能达到 O(n)，怎么优化？"></a>针对 HashMap 中某个 Entry 链太长，查找的时间复杂度可能达到 O(n)，怎么优化？</h3><p>将链表转为红黑树，实现 O(logn) 时间复杂度内查找。JDK1.8 已经实现了。</p>
<h3 id="如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h3><p>扩容。这个过程也叫作rehashing，因为它重建内部数据结构，并调用hash方法找到新的bucket位置。 大致分两步： </p>
<ol>
<li>扩容：容量扩充为原来的两倍（2 * table.length）； </li>
<li>移动：对每个节点重新计算哈希值，重新计算每个元素在数组中的位置，将原来的元素移动到新的哈希表中。<br>　　<br>补充： </li>
<li>loadFactor：加载因子。默认值DEFAULT_LOAD_FACTOR = 0.75f； </li>
<li>capacity：容量； </li>
<li>threshold：阈值=capacity<em>loadFactor。当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍（capacity</em>2）； </li>
<li>size：HashMap的大小，它是HashMap保存的键值对的数量。<h3 id="为什么String-Interger这样的类适合作为键？"><a href="#为什么String-Interger这样的类适合作为键？" class="headerlink" title="为什么String, Interger这样的类适合作为键？"></a>为什么String, Interger这样的类适合作为键？</h3>　　String, Interger这样的类作为HashMap的键是再适合不过了，而且String最为常用。<br>　　因为String对象是不可变的，而且已经重写了equals()和hashCode()方法了。<br>　　1.不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。<br>　　注：String的不可变性可以看这篇文章《【java基础】浅析String》。<br>　　2.因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。<h2 id="HashMap与HashTable区别"><a href="#HashMap与HashTable区别" class="headerlink" title="HashMap与HashTable区别"></a>HashMap与HashTable区别</h2>Hashtable可以看做是线程安全版的HashMap，两者几乎“等价”（当然还是有很多不同）。Hashtable几乎在每个方法上都加上synchronized（同步锁），实现线程安全。<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3></li>
<li>HashMap继承于AbstractMap，而Hashtable继承于Dictionary； </li>
<li>线程安全不同：Hashtable的几乎所有函数都是同步的，即它是线程安全的，支持多线程。而HashMap的函数则是非同步的，它不是线程安全的。若要在多线程中使用HashMap，需要我们额外的进行同步处理； </li>
<li>null值：HashMap的key、value都可以为null。Hashtable的key、value都不可以为null； </li>
<li>迭代器(Iterator)：HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException。 </li>
<li>容量的初始值和增加方式都不一样：HashMap默认的容量大小是16；增加容量时，每次将容量变为“原始容量x2”。Hashtable默认的容量大小是11；增加容量时，每次将容量变为“原始容量x2 + 1”； </li>
<li>添加key-value时的hash值算法不同：HashMap添加元素时，是使用自定义的哈希算法。Hashtable没有自定义哈希算法，而直接采用的key的hashCode()。 </li>
<li>速度。由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。<h3 id="能否让HashMap同步？"><a href="#能否让HashMap同步？" class="headerlink" title="能否让HashMap同步？"></a>能否让HashMap同步？</h3>HashMap可以通过下面的语句进行同步：Map m = Collections.synchronizeMap(hashMap);<h2 id="求两个list的并集、交集、差集？"><a href="#求两个list的并集、交集、差集？" class="headerlink" title="求两个list的并集、交集、差集？"></a>求两个list的并集、交集、差集？</h2></li>
</ol>
<ul>
<li>并集：list1.addAll(list2);</li>
<li>交集：list1.retainAll(list2);</li>
<li>差集：list1.removeAll(list2);</li>
</ul>
	
		</div>
		
		<div id="current-post-cover" data-scr="/img/cart_cover.jpg"></div>

		<!-- relate post, comment...-->
		<div class="investment-container">
			<div class="investment-header">
				<div class="investment-title-1">
					<div class="on">相关文章</div>
					<div>评论</div>
					<div>分享</div>
				</div>
				<div class="investment-title-2">	            
					
	<span>
		<a id="totop-post-page">返回顶部</a>
		
			<a href="/2021/05/12/notes/framework/Zookeeper/" title="Zookeeper" rel="prev">
				&laquo;上一篇
			</a>
		
		
			<a href="/2021/05/12/notes/database/Redis/" title="Redis" rel="next">
				下一篇&raquo;
			</a>
			
	</span>


      		
				</div>	
			</div>
			
			<div class="investment-content">
				<div class="investment-content-list">
					

<div class="relate-post">
	
		<ul>
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/05/12/notes/java/Java%E5%B9%B6%E5%8F%91/" title="Java并发">
								Java并发			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 12日, 2021				
							</p>
							<p class="relate-post-content">
								什么是线程安全，怎么保证线程安全？线程安全可以简单理解为一个方法或者一个实例可以在多线程环境中使用而不会出现问题
如何保证线程安全
JAVA 线程状态转换图示线程共包括以下5种状态。

新建状态(New)         : 线程对象...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/05/12/notes/java/Java%E5%B9%B6%E5%8F%91/" title="Java并发">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="Java并发"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/05/12/notes/java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="Java虚拟机">
								Java虚拟机			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 12日, 2021				
							</p>
							<p class="relate-post-content">
								JVM内存结构 VS Java内存模型 VS Java对象模型JVM内存结构Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，其中有些区域随着虚拟机...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/05/12/notes/java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="Java虚拟机">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="Java虚拟机"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/05/12/notes/java/Java%E5%9F%BA%E7%A1%80/" title="Java基础">
								Java基础			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 12日, 2021				
							</p>
							<p class="relate-post-content">
								JAVA开发六大原则
单一原则 : 一个类或一个方法只负责一件事情
里斯替换原则: 子类不应该重写父类已实现的方法,重载不应该比父类的参数更少
依赖倒置原则: 面向接口编程.（面向接口更能添加程序的可扩展性）
接口隔离原则: 接口中的...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/05/12/notes/java/Java%E5%9F%BA%E7%A1%80/" title="Java基础">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="Java基础"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/05/12/notes/network/Computer-Network/" title="Computer-Network">
								Computer-Network			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 12日, 2021				
							</p>
							<p class="relate-post-content">
								TCPTCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。
T...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/05/12/notes/network/Computer-Network/" title="Computer-Network">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="Computer-Network"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/05/12/notes/algorithms/DataStructures-Algorithms/" title="DataStructures-Algorithms">
								DataStructures-Algorithms			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 12日, 2021				
							</p>
							<p class="relate-post-content">
								动态规划动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。
背包问题总结背包问题 (Knapsack problem x )...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/05/12/notes/algorithms/DataStructures-Algorithms/" title="DataStructures-Algorithms">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="DataStructures-Algorithms"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/05/12/notes/database/DataBaseDesign/" title="DataBaseDesign">
								DataBaseDesign			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 12日, 2021				
							</p>
							<p class="relate-post-content">
								MySQL数据库开发规范
所有的数据库对象名称必须使用小写字母并用下划线分割（MySQL大小敏感，见名知意，最好不超过32字符）
所有的数据库对象名称禁止使用MySQL保留关键字（如 desc、range、match、delayed ...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/05/12/notes/database/DataBaseDesign/" title="DataBaseDesign">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="DataBaseDesign"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/05/12/notes/design/Design-Patterns/" title="Design-Patterns">
								Design-Patterns			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 12日, 2021				
							</p>
							<p class="relate-post-content">
								设计模式主要分三个类型:创建型、结构型和行为型。创建型

Singleton，单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点 
Abstract Factory，抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/05/12/notes/design/Design-Patterns/" title="Design-Patterns">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="Design-Patterns"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/05/12/notes/framework/MyBatis/" title="MyBatis">
								MyBatis			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 12日, 2021				
							</p>
							<p class="relate-post-content">
								MyBatis介绍在介绍MyBatis之前先简单了解几个概念：ORM，JPA。
ORMORM（Object-Relationship-Mapping）：是对象关系映射的意思，它是一种思想，是指将数据库中的每一行数据用对象的形式表现出来...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/05/12/notes/framework/MyBatis/" title="MyBatis">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="MyBatis"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/05/12/notes/framework/Nginx/" title="Nginx">
								Nginx			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 12日, 2021				
							</p>
							<p class="relate-post-content">
								Nginx是什么？Nginx是一个开源且高性能、可靠的HTTP中间件、代理服务其他的HTTP服务：

HTTPD-Apache基金会
IIS-微软
GWS-Google(不对外开放)我们为什么选择Nginx？1. IO多路复用epol...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/05/12/notes/framework/Nginx/" title="Nginx">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="Nginx"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/05/12/notes/framework/Solr/" title="Solr">
								Solr			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 12日, 2021				
							</p>
							<p class="relate-post-content">
								solr原理索引Solr/Lucene采用的是一种反向索引（倒排索引），所谓反向索引：就是从关键字到文档的映射过程，保存这种映射这种信息的索引称为反向索引

左边保存的是字符串序列
右边是字符串的文档（Document）编号链表，称为...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/05/12/notes/framework/Solr/" title="Solr">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="Solr"/>
							</a>
						</div>
					</li>												
			
		</ul>
	
</div>	
				</div>
				<div class="investment-content-list">
					<div class="layout-comment">

	
		<div class="config-info">
			Please check the parameter of <b>comment</b> in config.yml of hexo-theme-Annie!
		</div>	
	

</div>
				</div>
				<div class="investment-content-list">
					<div class="layout-share">
	
	

		
			
			<!-- socialShare share -->
			<div class="social-share"></div>

<!--  css & js -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
<script async src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
			
		
		
	
</div>


				</div>
			</div>	
		</div>
	</div>
</div>

<!-- show math formula -->



	 
	
<script src="/plugin/clipboard/clipboard.js"></script>

	<script>
		// Copy code !
	    function preprocessing() {
	        $("#article-content .highlight").each(function() {
	            $(this).wrap('<div id="post-code"></div>');
	        })

	        $("#article-content #post-code").each(function() {
	            $(this).prepend('<nav class="copy-nav"><span><i class="code-language"></i></span></nav>');
	        })

	        $("#article-content .copy-nav").each(function() {
	            let languageClass = $(this).next().attr('class'),
	                language = ((languageClass.length > 9) && (languageClass != null)) ? languageClass.substr(10) : "none"; //why 9? Need to check language?

	            $(this).find('.code-language').text(language);
	            $(this).append('<span class="copy-btn icon-paste"></span>');
	        });
	    }

		function copy() {
		    $('#article-content #post-code').each(function(i) {
		        let codeCopyId = 'codeCopy-' + i;

		        let codeNode = $(this).find('.code'),
		            copyButton = $(this).find('.copy-btn');

		        codeNode.attr('id', codeCopyId);
		        copyButton.attr('data-clipboard-target-id', codeCopyId);
		    })
   
			let clipboard = new ClipboardJS('.copy-btn', {
					target: function(trigger) {
						return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
					}
		      	});

			//pure js
			function showTooltip(elem, msg) {		   
				elem.setAttribute('aria-label', msg);
				elem.setAttribute('class', 'copy-btn icon-clipboard1');
				setTimeout(function() {
					elem.setAttribute('class', 'copy-btn icon-paste');
				}, 2000);
			}

			clipboard.on('success', function(e) {
			    e.clearSelection();
			    console.info('Action:', e.action);		   
			    console.info('Trigger:', e.trigger);
			    showTooltip(e.trigger, 'Copied!');   
			});
			
			clipboard.on('error', function(e) {
			    console.error('Action:', e.action);
			    console.error('Trigger:', e.trigger);
			});
		}
		
		(function copyCode(){
			if ($('.layout-post').length) {
			    preprocessing();
			    copy();
			} 
		})();
	</script>






<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">


<script src="/plugin/fancybox/jquery.fancybox.js"></script>


<script type="text/javascript">
	(function gallerySet(){
		let titleID = $('.article-title a'),
			imageID = $('.article-content img'),
			videoID = $('.article-content video');
		
		let postTitle = titleID.text() ? titleID.text() : "No post title!";
		
		imageID.each(function() {
			let imgPath = $(this).attr('src'),
				imgTitle = $(this).attr('alt') ? $(this).attr('alt') : "No image description!";
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox="gallery" data-caption="《 ' + postTitle + ' 》' + imgTitle + '"href="' + imgPath + '"> </a>');
		});
		
		videoID.each(function() {
			let videoPath = $(this).attr('src');
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox href=" ' + videoPath + ' "> </a>');
		});
		
		//TODO：支持html5 video

		if($('#layout-post').length) {
			$('[data-fancybox="gallery"]').fancybox({
				loop: true,
				buttons: [
					"zoom",
					"share",
					"slideShow",
					"fullScreen",
					//"download",
					"thumbs",
					"close"
				],
				protect: true
			});
		}
	})();
</script>
		</main>

		<!--footer-->
		<footer>
	<div id="navigation-show">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	

	
</ul>
	</div>

	<div class="copyright">
		<p>
			 
				&copy;2020 - 2021, content by Shawceng. All Rights Reserved.
			
			
				<a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> Theme <a href="https://github.com/Sariay/hexo-theme-Annie" title="Annie" target="_blank" rel="noopener">Annie</a> by Sariay.
			
		</p>
		<p>
			

	<!-- busuanzi -->
	<!-- busuanzi -->



			<a href="javascript:zh_tran('s');" class="zh_click" id="zh_click_s">简体</a> 
			<a href="javascript:zh_tran('t');" class="zh_click" id="zh_click_t">繁體</a>				
		</p>
	</div>		
</footer>
		
	<!-- Local or hitokoto! -->

	
<script src="/plugin/motto/motto.js"></script>

	
	<script type="text/javascript">
		(function motto(){
			let mottoText = getMingYanContent().split('</br> - </br>'),
			
			mottoTextContent = mottoText[0]?mottoText[0]:'请刷新...',
			
			mottoTextFrom = mottoText[1]?mottoText[1]:'one/一个';
			
			mottoTextContent = mottoTextContent.trim().substring(0, 100);
		
			$("#motto-content").html( mottoTextContent);
			$("#motto-author").html( mottoTextFrom  );
		})();	
	</script>	



<!-- love effect -->


<!-- back to top -->

	<div id="totop">
	<span class="icon-circle-up"></span>
</div>



<!-- site analysis -->


	<!-- site-analysis -->
	
	
	
	
	
 

<!-- leancloud -->


	<!-- leancloud -->
	<!--
	时间：2018-11-27
	描述：
		文章访问量：visitors
		文章喜欢量：likes	
		文章排行榜：topNPost
		其他得说明：
			01-Cookie相关的函数 
				https://blog.csdn.net/somehow1002/article/details/78511541（Author：somehow1002）
			02-visitors相关的函数 
				https://blog.csdn.net/u013553529/article/details/63357382（Author：爱博客大伯）
				https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html（Author：夏末）
			03-topNPost相关的函数
				https://hoxis.github.io/hexo-next-read-rank.html（Author：hoxis）
			04-likes相关的函数，
				参考了01 & 02进行简单的设计与实现
-->


	

  



<script src="/plugin/chinese/chinese.js"></script>
<script src="/plugin/imagelazyloader/yall.min.js"></script>
<script src="/plugin/imageloaded/imagesloaded.pkgd.min.js"></script>
<script src="/plugin/nicescroll/jquery.nicescroll.js"></script>
<script src="/plugin/resizediv/resizediv.js"></script>
<script src="/js/main.js"></script>

	</body>	
</html>